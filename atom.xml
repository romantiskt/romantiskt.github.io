<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rolan的Android之旅</title>
  <icon>https://www.gravatar.com/avatar/b0a2c88b3d0def26b9fac747fb36dd1f</icon>
  <subtitle>读万卷书，行万里路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-31T11:51:22.786Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>romantiskt</name>
    <email>wangyangRx@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java锁之前世今生</title>
    <link href="http://yoursite.com/2019/07/31/Java%E9%94%81%E4%B9%8B%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://yoursite.com/2019/07/31/Java锁之前世今生/</id>
    <published>2019-07-31T11:34:00.000Z</published>
    <updated>2019-07-31T11:51:22.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java锁之前世今生"><a href="#Java锁之前世今生" class="headerlink" title="Java锁之前世今生"></a>Java锁之前世今生</h2><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>&nbsp;&nbsp;为保障多线程下处理共享数据的安全性，Java 语言给我们提供了线程锁，保证同一时刻只有一个线程能处理共享数据。当一个锁被某个线程持有的时候，另一个线程尝试去获取这个锁将产生线程阻塞，直到持有锁的线程释放了该锁。<br>&nbsp;&nbsp;不过值得注意的是，能产生线程阻塞的不仅仅是锁，Object.wait(),Thread.sleep(), ArrayBlockingQueue.put()等也能产生类似的效果，包括while(true)也是，<strong>自旋锁</strong>就是通过循环 do while来实现。这里有必要介绍一下几种我们常说的几个名词的概念</p><ul><li><strong>自旋锁</strong><br>&nbsp;&nbsp;阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁，所谓自旋，不过就是原地进行循环，不停去获取锁</li><li><strong>适应性自旋锁</strong><br>&nbsp;&nbsp;自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li><li><strong>悲观锁</strong><br>  &nbsp;&nbsp;对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li><strong>乐观锁</strong><br>  &nbsp;&nbsp;使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试[自旋操作]）<blockquote><p>乐观锁的实现方式：<br>CAS算法涉及到三个操作数：<br>1.需要读写的内存值 V。<br>2.进行比较的值 A。<br>3.要写入的新值 B。<br>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁</p></blockquote></li></ul><p>&nbsp;&nbsp;Java加锁的方式有两种：[这两种都是悲观锁的实现]</p><ol><li>Synchronized</li><li>显式Lock  </li></ol><h2 id="2、volatile"><a href="#2、volatile" class="headerlink" title="2、volatile"></a>2、volatile</h2><p>&nbsp;&nbsp;被volatile修饰的变量具有可见性，可见性也就是说一旦某个线程修改了该被volatile修饰的变量，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，可以立即获取修改之后的值。在Java中为了加快程序的运行效率，对一些变量的操作通常是在该线程的寄存器或是CPU缓存上进行的，之后才会同步到主存中，而加了volatile修饰符的变量则是直接读写主存  </p><p><strong>volatile和synchronized的区别</strong></p><ul><li>volatile虽然具有可见性但是并不能保证原子性,<blockquote><p>原子性：指一个操作是不可中断的，要么全部执行成功要么全部执行失败，在Java中，对基本数据类型的变量和赋值操作都是原子性操作，i++这种就不属于原子操作【此处可拓展：原子性，可见性，有序性】<br>参考<a href="https://blog.csdn.net/eff666/article/details/66473088" target="_blank" rel="external">并发编程——原子性，可见性和有序性</a></p></blockquote></li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化<h2 id="3、Synchronized"><a href="#3、Synchronized" class="headerlink" title="3、Synchronized"></a>3、Synchronized</h2> Synchronized是java中的一个关键字，可以用来修饰类方法，对象方法和代码块，如下所示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static synchronized void doSomething()&#123;&#125;//类锁</div><div class="line">    </div><div class="line">    public synchronized void doSomething2()&#123;&#125;</div><div class="line">    </div><div class="line">    public void test()&#123;</div><div class="line">        synchronized(this)&#123;//对象锁</div><div class="line">            //dosomething</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;类锁和对象锁没有多大关系，两者并不冲突，在多线程运行进入对象锁的方法中时，其它线程也还是可以访问被类锁加锁的方法</p><ul><li><strong>可重入锁</strong><br>&nbsp;&nbsp;可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Widget &#123;</div><div class="line">    public synchronized void doSomething() &#123;</div><div class="line">        System.out.println(&quot;方法1执行...&quot;);</div><div class="line">        doOthers();</div><div class="line">    &#125;</div><div class="line">    public synchronized void doOthers() &#123;</div><div class="line">        System.out.println(&quot;方法2执行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-1、synchronized的原理"><a href="#3-1、synchronized的原理" class="headerlink" title="3.1、synchronized的原理"></a>3.1、<strong>synchronized的原理</strong></h3><ol><li>&nbsp;&nbsp;当对方法加锁时，编译之后会在方法中加入ACC_SYNCHRONIZED标识，加锁应该是交给了虚拟机去实现  </li><li>&nbsp;&nbsp;当对代码块加锁时，编译的字节码中会多出一些指令， monitorenter，monitorexit 来进入和退出同步，而且其中会包含异常处理的代码，来保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//编译前</div><div class="line">public static void print2() &#123;</div><div class="line">        synchronized(Lock.class) &#123;</div><div class="line">            System.out.println(&quot;synchronized&quot;);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">//字节码-&gt;</div><div class="line">public static void print2();</div><div class="line">    descriptor: ()V</div><div class="line">    flags: ACC_PUBLIC, ACC_STATIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=2, args_size=0</div><div class="line">         0: ldc #5    // 将锁对象 Lock.class 入栈</div><div class="line">         2: dup // 复制一份，此时栈中有两个 Lock.class </div><div class="line">         3: astore_0 // 出栈一个 Lock.class 对象保存到局部变量表 Slot 1 中</div><div class="line">         4: monitorenter // 以栈顶元素 Lock.class 作为锁，开始同步</div><div class="line">         5: getstatic #2    // 5-10 调用 System.out.println(&quot;synchronized&quot;);</div><div class="line">         8: ldc #6</div><div class="line">        10: invokevirtual #4</div><div class="line">        13: aload_0 // 将局部变量表 Slot 1 中的数据入栈，即 Lock.class</div><div class="line">        14: monitorexit // 使用栈顶数据退出同步</div><div class="line">        15: goto 23 // 方法结束，跳转到 23 返回</div><div class="line">        18: astore_1 // 从这里开始是异常路径，将异常信息保存至局部变量表 Slot 2 中，查看异常表</div><div class="line">        19: aload_0 // 将局部变量表 Slot 1 中的 Lock.class 入栈</div><div class="line">        20: monitorexit // 使用栈顶数据退出同步</div><div class="line">        21: aload_1 // 将局部变量表 Slot 2 中的异常信息入栈</div><div class="line">        22: athrow // 把异常对象重新抛出给方法的调用者</div><div class="line">        23: return // 方法正常返回</div><div class="line">      Exception table: // 异常表</div><div class="line">         from    to  target type</div><div class="line">             5    15    18   any // 5-15 出现任何(any)异常跳转到 18 </div><div class="line">            18    21    18   any // 18-21 出现任何(any)异常跳转到 18</div></pre></td></tr></table></figure><p> <strong>monitorenter：</strong><br>&nbsp;&nbsp;每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：<br>1.如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。<br>2.如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。<br>3.如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。  </p><p> <strong>monitorexit：</strong><br>&nbsp;&nbsp;只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor  </p><p><strong>锁升级</strong><br>&nbsp;&nbsp;如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统所实现的锁我们称之为“<strong>重量级锁</strong>”<br>&nbsp;&nbsp;JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”<br>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级  </p><ul><li>无锁：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功</li><li>偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</li><li>轻量级锁：当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能</li><li>重量级锁：等待锁的线程都会进入阻塞状态</li></ul><h2 id="4、显式Lock"><a href="#4、显式Lock" class="headerlink" title="4、显式Lock"></a>4、显式Lock</h2><p>基本使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Lock lock = new ReentrantLock();</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line">    //处理任务</div><div class="line">&#125;catch(Exception ex)&#123;</div><div class="line">     </div><div class="line">&#125;finally&#123;</div><div class="line">    lock.unlock();   //释放锁</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>tryLock():</strong>     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false</div></pre></td></tr></table></figure><p><strong>tryLock(long time, TimeUnit unit)</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间</div></pre></td></tr></table></figure><p><strong>其它接口：</strong><br>ReadWriteLock内部有实现了Lock类接口的ReadLock读锁和写锁WriteLock,以此将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作，实现类ReentrantReadWriteLock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line"></div><div class="line">rwl.readLock().lock();</div><div class="line">rwl.readLock().unlock();</div></pre></td></tr></table></figure><h2 id="5、结语"><a href="#5、结语" class="headerlink" title="5、结语"></a>5、结语</h2><p>&nbsp;&nbsp;Lock锁在刚出来的时候很多性能方面都比Synchronized锁要好，但是从JDK1.6开始Synchronized锁就做了各种的优化，包括适应自旋锁，锁消除，锁粗化，轻量级锁，偏向锁。<br>&nbsp;&nbsp;所以，到现在Lock锁和Synchronized锁的性能其实差别不是很大！而Synchronized锁用起来又特别简单。Lock锁还得顾忌到它的特性，要手动释放锁才行  </p><p><strong>名词解释</strong>  </p><ul><li><strong>锁粗化（Lock Coarsening）</strong>：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁</li><li><strong>锁消除（Lock Elimination）</strong>：锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。</li></ul><h2 id="6、参考文档"><a href="#6、参考文档" class="headerlink" title="6、参考文档"></a>6、参考文档</h2><ol><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="external">美团团队不可不说的Java“锁”事</a>  </li><li><a href="https://juejin.im/post/5adf14dcf265da0b7b358d58" target="_blank" rel="external">Java锁机制了解一下</a>  </li><li><a href="https://pqpo.me/2019/01/30/learn-java-lock-block/" target="_blank" rel="external">深入理解 Java 锁与线程阻塞</a>  </li><li><a href="https://www.jianshu.com/p/e674ee68fd3f" target="_blank" rel="external">Java中的锁[原理、锁优化、CAS、AQS]</a></li><li><a href="https://blog.csdn.net/yangzhaomuma/article/details/51236976" target="_blank" rel="external">Java多线程简析——Synchronized（同步锁）、Lock以及线程池</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java锁之前世今生&quot;&gt;&lt;a href=&quot;#Java锁之前世今生&quot; class=&quot;headerlink&quot; title=&quot;Java锁之前世今生&quot;&gt;&lt;/a&gt;Java锁之前世今生&lt;/h2&gt;&lt;h2 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>基于ASM的AOP编程</title>
    <link href="http://yoursite.com/2019/07/13/%E5%9F%BA%E4%BA%8EASM%E7%9A%84AOP%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/13/基于ASM的AOP编程/</id>
    <published>2019-07-13T15:34:00.000Z</published>
    <updated>2019-07-16T06:45:57.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于ASM的AOP编程"><a href="#基于ASM的AOP编程" class="headerlink" title="基于ASM的AOP编程"></a>基于ASM的AOP编程</h3><h5 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h5><p>AOP，国内大致译作“面向切面编程”。可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。</p><h5 id="AOP技术有哪些"><a href="#AOP技术有哪些" class="headerlink" title="AOP技术有哪些"></a>AOP技术有哪些</h5><ul><li>AspectJ，可参考比较稳定的一个开源框架<a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="external">gradle_plugin_android_aspectjx</a></li><li>Javassist，我前面有提到过，使用起来比较简单，但是生成代码的效率会比较低</li><li>ASM，是大多数开源框架的首选，但是上手难度比较大，对新手不太友好</li></ul><p>本文会围绕如何用ASM来实现butterknife的功能来介绍ASM的核心原理和使用方法，贴出的代码皆为实验demo，参数及函数体的改变可能会要做出修改，实现不是很优雅，仅供参考(butterknife核心实现是基于AbstractProcessor，我们这里只是把AbstractProcessor的功能替换成ASM)。</p><h5 id="1-0-包插件架构"><a href="#1-0-包插件架构" class="headerlink" title="1.0-包插件架构"></a>1.0-包插件架构</h5><p>首先我们创建好annotations库，runtime运行库，及其gradle-plugin插件库。</p><ul><li>curdhook-annotations</li><li>curdhook-runtime</li><li>curdhook-gradle-plugin<blockquote><p>之所以命名为curd，是因为我开始本来想做一个可配置化的增删改查的插件，配置想要生成的代码，或是想要删除的方法或者类，<br>但是后来发现工作量太大，而且对于asm来说，我们往代码中加入的代码也需要是字节码代码，会对使用者有很大的学习成本，<br>还不如直接编写插件对代码进行变更要来得快，所以后来我就放弃了，不过我已经在demo中实现了增删改查，如果有业务需求的，可以按我写的例子去实现即可</p></blockquote></li></ul><h5 id="1-1-curdhook-annotations"><a href="#1-1-curdhook-annotations" class="headerlink" title="1.1-curdhook-annotations"></a>1.1-curdhook-annotations</h5><p>创建BindView注解和Unbinder接口(完全仿造butterknife)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">@Target(ElementType.FIELD)</div><div class="line">public @interface BindView &#123;</div><div class="line">    /** View ID to which the field will be bound. */</div><div class="line">    @IdRes int value();</div><div class="line">&#125;</div><div class="line">-------------------------------------------------------------</div><div class="line">public interface Unbinder &#123;</div><div class="line">    void unbind();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="1-2-curdhook-runtime"><a href="#1-2-curdhook-runtime" class="headerlink" title="1.2-curdhook-runtime"></a>1.2-curdhook-runtime</h5><p>因为我们使用asm生成的是类文件xxx_ViewBinding.class，此类中会对findViewById做出处理，我们在每个需要注入的地方需要new出生成类的实例，所以我们这里单独抽出一个库来包装这一功能，代码完全参考butterknife</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public class HookCode &#123;</div><div class="line">    private static final String TAG = &quot;HookCode&quot;;</div><div class="line">    private static boolean debug = false;</div><div class="line">    static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    public static Unbinder bind(@NonNull Activity target) &#123;</div><div class="line">        View sourceView = target.getWindow().getDecorView();</div><div class="line">        return bind(target, sourceView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Unbinder bind(@NonNull View target) &#123;</div><div class="line">        return bind(target, target);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static Unbinder bind(@NonNull Object target, @NonNull View source) &#123;</div><div class="line">        Class&lt;?&gt; targetClass = target.getClass();</div><div class="line">        if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName());</div><div class="line">        Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</div><div class="line"></div><div class="line">        if (constructor == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</div><div class="line">        try &#123;</div><div class="line">            return constructor.newInstance(target, source);</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</div><div class="line">        &#125; catch (InvocationTargetException e) &#123;</div><div class="line">            Throwable cause = e.getCause();</div><div class="line">            if (cause instanceof RuntimeException) &#123;</div><div class="line">                throw (RuntimeException) cause;</div><div class="line">            &#125;</div><div class="line">            if (cause instanceof Error) &#123;</div><div class="line">                throw (Error) cause;</div><div class="line">            &#125;</div><div class="line">            throw new RuntimeException(&quot;Unable to create binding instance.&quot;, cause);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</div><div class="line">        Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</div><div class="line">        if (bindingCtor != null || BINDINGS.containsKey(cls)) &#123;</div><div class="line">            if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);</div><div class="line">            return bindingCtor;</div><div class="line">        &#125;</div><div class="line">        String clsName = cls.getName();</div><div class="line">        if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)</div><div class="line">                || clsName.startsWith(&quot;androidx.&quot;)) &#123;</div><div class="line">            if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</div><div class="line">            //noinspection unchecked</div><div class="line">            bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</div><div class="line">            if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());</div><div class="line">            bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</div><div class="line">        &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);</div><div class="line">        &#125;</div><div class="line">        BINDINGS.put(cls, bindingCtor);</div><div class="line">        return bindingCtor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="1-3-curdhook-gradle-plugin"><a href="#1-3-curdhook-gradle-plugin" class="headerlink" title="1.3-curdhook-gradle-plugin"></a>1.3-curdhook-gradle-plugin</h5><p>如何编写一个Android插件，我前面已经介绍过，这里不再重复，这里我们主要利用Transform对class-&gt;dex这个过程进行hook,</p><ul><li><p>plugin入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class CurdPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        println &apos;project apply crud-register plugin&apos;</div><div class="line">        def isApp = project.plugins.hasPlugin(AppPlugin)</div><div class="line">        if(isApp)&#123;</div><div class="line">            def android = project.extensions.getByType(AppExtension)</div><div class="line">            def transform = new CurdTransform()</div><div class="line">            android.registerTransform(transform)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在我们自己实现的CurdTransform中实现transform方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    void transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException &#123;</div><div class="line">        println &quot;transform  start .....&quot;</div><div class="line">        if (!isIncremental) &#123;</div><div class="line">            outputProvider.deleteAll()</div><div class="line">        &#125;</div><div class="line">        inputs.each &#123; TransformInput transformInput -&gt;</div><div class="line">            transformInput.jarInputs.each &#123; JarInput jarInput -&gt;</div><div class="line">                println(&quot;jarPath:&quot; + jarInput.file.absolutePath)</div><div class="line">                File src = jarInput.file</div><div class="line">                File dest = getDestFile(jarInput, outputProvider)</div><div class="line">                FileUtils.copyFile(src, dest)</div><div class="line">            &#125;</div><div class="line">            transformInput.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</div><div class="line">                println(&quot;Path:&quot; + directoryInput.file.absolutePath)</div><div class="line">                directoryInput.file.eachFileRecurse &#123; File file -&gt;//将目录下面所有的文件和目录输出</div><div class="line">                    injectFile(file)</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">                File dest = outputProvider.getContentLocation(directoryInput.name, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</div><div class="line">                FileUtils.copyDirectory(directoryInput.file, dest)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>然后将功能委托出去，我们这里只处理.class文件，对jar文件过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void injectFile(File file) &#123;</div><div class="line">       def name = file.name</div><div class="line">       if (name.endsWith(&quot;.class&quot;)</div><div class="line">               &amp;&amp; !name.startsWith(&quot;R\$&quot;)</div><div class="line">               &amp;&amp; &quot;R.class&quot; != name</div><div class="line">               &amp;&amp; &quot;BuildConfig.class&quot; != name) &#123;</div><div class="line">           new ScanTask(file).scan().write2File()</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ul><h5 id="2-0-扫描"><a href="#2-0-扫描" class="headerlink" title="2.0-扫描"></a>2.0-扫描</h5><p>在注入代码之前，我们需要对类代码扫描。得到我们需要注入的信息，包括注入的字段，值，类信息等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ScanTask scan() throws IOException &#123;</div><div class="line">       Log.v(&quot;scanClassFile: %s&quot;, this.mClassFile.getAbsolutePath());</div><div class="line">       this.mClassByteCode = Utils.file2bytes(new FileInputStream(this.mClassFile));</div><div class="line">       ClassReader classReader = new ClassReader(this.mClassByteCode);</div><div class="line">       classReader.accept(new ScanClassVisitor(injectCode), ClassReader.SKIP_DEBUG + ClassReader.SKIP_FRAMES + ClassReader.SKIP_CODE);</div><div class="line">       return this;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>这里先将文件转为字节流，然后使用asm api去读取，然后将我们自己的实现类传入，在asm字节码代码中会有一些debug信息，我们可以直接传入flag忽略这些信息</p><h5 id="2-1-ClassVisitor"><a href="#2-1-ClassVisitor" class="headerlink" title="2.1-ClassVisitor"></a>2.1-ClassVisitor</h5><p>顾名思义，这是我们对class输入流的一个抽象类，我们需要继承并实现对应的方法，class中类信息，字段，方法，匿名内部类，类注解都有相应的抽象方法，这样在扫描过程中就会被逐个调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> //类信息，例如实现接口，父类，类名等</div><div class="line"> @Override</div><div class="line">    public void visit(int version, int access, String name, String signature,</div><div class="line">                      String superName, String[] interfaces)</div><div class="line">-------------------------------------------------------------</div><div class="line">//字段</div><div class="line">@Override</div><div class="line">    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value)</div><div class="line">-------------------------------------------------------------</div><div class="line">//方法</div><div class="line"> @Override</div><div class="line">    public MethodVisitor visitMethod(int access, String name, String desc,</div><div class="line">                                     String signature, String[] exceptions)</div><div class="line"> -------------------------------------------------------------</div><div class="line"> //内部类</div><div class="line"> @Override</div><div class="line">    public void visitInnerClass(String name, String outerName, String innerName, int access)</div></pre></td></tr></table></figure></p><h5 id="2-2-FieldVisitor"><a href="#2-2-FieldVisitor" class="headerlink" title="2.2-FieldVisitor"></a>2.2-FieldVisitor</h5><p>字段扫描代理，例如我们如果需要知道类中字段上的注解信息，我们就继承FieldVisitor，然后实现visitAnnotation，我们就能得到字段上注解信息处理的入口，需要注意的是，我们这里自己实现的FieldVisitor需要在ClassVisitor中实现visitField方法然后传入，下面的method,注解也是一个道理，有点像是事件的分发代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public AnnotationVisitor visitAnnotation(String desc, boolean visible)</div></pre></td></tr></table></figure></p><h5 id="2-3-MethodVisitor"><a href="#2-3-MethodVisitor" class="headerlink" title="2.3-MethodVisitor"></a>2.3-MethodVisitor</h5><p>方法扫描代理，类似FieldVisitor，如果我们也需要知道方法上的注解信息，我们同样也可以实现然后实现visitAnnotation，得到处理注解的入口</p><h5 id="2-4-AnnotationVisitor"><a href="#2-4-AnnotationVisitor" class="headerlink" title="2.4-AnnotationVisitor"></a>2.4-AnnotationVisitor</h5><p>上面字段和方法实现visitAnnotation得到的注解入口，如果需要知道详细的注解信息，我们还需要自己实现AnnotationVisitor，然后实现下面几个方法才能拿到更为详细的信息，同样的，我们自己实现的实例需要再对应方法或是字段实现类中的visitAnnotation传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void visit(String name, Object value)</div><div class="line"> public void visitEnum(String name, String desc, String value) &#123;</div></pre></td></tr></table></figure></p><h5 id="3-0-注入"><a href="#3-0-注入" class="headerlink" title="3.0-注入"></a>3.0-注入</h5><p>在经过扫描之后，我们已经获取了扫描类的信息，接下来我们就需要将代码注入，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void write2File() &#123;</div><div class="line">        Utils.write2file(this.mClassFile, inject());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private byte[] inject() &#123;</div><div class="line">        ClassReader classReader = new ClassReader(this.mClassByteCode);</div><div class="line">        ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</div><div class="line">        ClassVisitor cv = new InjectClassVisitor(classWriter,injectCode);</div><div class="line">        classReader.accept(cv, ClassReader.EXPAND_FRAMES);</div><div class="line">        //verify the generated bytecode</div><div class="line">        new ClassReader(classWriter.toByteArray()).accept(new CheckClassAdapter(new ClassWriter(0)), ClassReader.EXPAND_FRAMES);</div><div class="line">        return classWriter.toByteArray();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这里实现类InjectClassVisitor并没有对ClassVisitor做其它处理，因为我们只是根据被扫描类，来决定是否创建xx_ViewBing.class，所以只是实现了visitEnd方法，在末尾执行我们创建类的操作,如果我们需要在被扫描类中注入字段，或者是方法，或者是修改方法，可以在相应的visitField，visitMethod中方法实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void visitEnd() &#123;</div><div class="line">       super.visitEnd();</div><div class="line">       injectCode.injectCode();</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h5 id="3-1-检查"><a href="#3-1-检查" class="headerlink" title="3.1-检查"></a>3.1-检查</h5><p>我们需要对扫描类进行检查是否应该创建新的xx_ViewBind.class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private boolean checkClassCanInject() &#123;</div><div class="line">        if (this.classEntity != null) &#123;</div><div class="line">            Set&lt;FieldEntity&gt; fields = this.classEntity.getField();</div><div class="line">            for (FieldEntity fieldEntity : fields) &#123;</div><div class="line">                Set&lt;AnnotationEntity&gt; annotation = fieldEntity.getAnnotation();</div><div class="line">                for (AnnotationEntity annotationEntity : annotation) &#123;</div><div class="line">                    if (&quot;Lcom/rolan/annotations/BindView;&quot;.equals(annotationEntity.typeDesc)) &#123;</div><div class="line">                        return true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h5 id="3-2-创建输出流"><a href="#3-2-创建输出流" class="headerlink" title="3.2-创建输出流"></a>3.2-创建输出流</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void injectCode(ClassEntity classEntity) &#123;</div><div class="line">      this.classEntity = classEntity;</div><div class="line">      byte[] bytes = new byte[0];</div><div class="line">      try &#123;</div><div class="line">          String writePath=getWritePath() + File.separator + getWriteClassName();</div><div class="line">          if(!new File(writePath).exists())&#123;</div><div class="line">              FileOutputStream outputStream = new FileOutputStream(writePath);</div><div class="line">              ClassWriter cw = new ClassWriter(0);</div><div class="line">              addClass(cw);</div><div class="line"></div><div class="line">              bytes = cw.toByteArray();</div><div class="line">              outputStream.write(bytes);</div><div class="line">              outputStream.close();</div><div class="line">          &#125;</div><div class="line">      &#125; catch (IOException e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h5 id="3-3-根据字节码生成代码"><a href="#3-3-根据字节码生成代码" class="headerlink" title="3.3-根据字节码生成代码"></a>3.3-根据字节码生成代码</h5><p>此处我们可以先编写好java文件，然后利用ASM Bytecode Viewer生成字节码代码，然后剔除掉无用的代码</p><ul><li>创建一个类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cv.visit(Opcodes.V1_7,</div><div class="line">               Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER,</div><div class="line">               getCreateJavaPath(), null,</div><div class="line">               &quot;java/lang/Object&quot;, new String[]&#123;&quot;com/rolan/annotations/Unbinder&quot;&#125;);</div><div class="line">       cv.visitSource(“xxx_ViewBinding.java, null);</div></pre></td></tr></table></figure><ul><li>生成成员变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FieldVisitor fieldVisitor = cv.visitField(Opcodes.ACC_PRIVATE, &quot;target&quot;, getCreateVarPath(), null, null);</div><div class="line">       fieldVisitor.visitEnd();</div></pre></td></tr></table></figure><ul><li>构造方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MethodVisitor mw = cv.visitMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;(&quot; + getCreateVarPath() + &quot;Landroid/view/View;)V&quot;, null, null);</div><div class="line">       mw.visitCode();</div><div class="line">       mw.visitVarInsn(Opcodes.ALOAD, 0);</div><div class="line">       mw.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);</div><div class="line">       mw.visitVarInsn(Opcodes.ALOAD, 0);</div><div class="line">       mw.visitVarInsn(Opcodes.ALOAD, 1);</div><div class="line">       mw.visitFieldInsn(Opcodes.PUTFIELD, getCreateJavaPath(), &quot;target&quot;, getCreateVarPath());</div></pre></td></tr></table></figure><ul><li><p>调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Integer id = (Integer) annotationEntity.getValue();</div><div class="line">                    if (id == null || id.intValue() &lt; 0)</div><div class="line">                        continue;</div><div class="line">                    mw.visitVarInsn(Opcodes.ALOAD, 0);</div><div class="line">                    mw.visitFieldInsn(Opcodes.GETFIELD, getCreateJavaPath(), &quot;target&quot;, getCreateVarPath());</div><div class="line">                    mw.visitVarInsn(Opcodes.ALOAD, 2);</div><div class="line">                    mw.visitLdcInsn(id);</div><div class="line">                    mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;android/view/View&quot;, &quot;findViewById&quot;, &quot;(I)Landroid/view/View;&quot;, false);</div><div class="line">                    mw.visitTypeInsn(Opcodes.CHECKCAST, Type.getType(entity.desc).getInternalName());</div><div class="line">                    mw.visitFieldInsn(Opcodes.PUTFIELD, getClassPath(), entity.name, entity.desc);</div><div class="line">                     mw.visitInsn(Opcodes.RETURN);</div><div class="line">        mw.visitMaxs(3 * i, 3 * i);</div></pre></td></tr></table></figure></li><li><p>创建方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, &quot;unbind&quot;, &quot;()V&quot;, null, null);</div><div class="line">       mv.visitCode();</div><div class="line">       mv.visitVarInsn(Opcodes.ALOAD, 0);</div><div class="line">       mv.visitInsn(Opcodes.ACONST_NULL);</div><div class="line">       mv.visitFieldInsn(Opcodes.PUTFIELD, getCreateJavaPath(), &quot;target&quot;, getCreateVarPath());</div><div class="line">       mv.visitVarInsn(Opcodes.ALOAD, 0);</div><div class="line">       mv.visitFieldInsn(Opcodes.GETFIELD, getCreateJavaPath(), &quot;target&quot;, getCreateVarPath());</div><div class="line">       mv.visitInsn(Opcodes.ACONST_NULL);</div><div class="line">       mv.visitFieldInsn(Opcodes.PUTFIELD, getClassPath(), &quot;content&quot;, &quot;Landroid/widget/TextView;&quot;);</div><div class="line">        mv.visitInsn(Opcodes.RETURN);</div><div class="line">       mv.visitMaxs(2, 1);</div></pre></td></tr></table></figure></li></ul><blockquote><p>上面贴出的代码为demo的代码，详细可以参考我写的demo</p></blockquote><h5 id="ASM注意的地方"><a href="#ASM注意的地方" class="headerlink" title="ASM注意的地方"></a>ASM注意的地方</h5><ul><li><p>插件库需要统一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1.com.android.tools.build:gradle:2.2.0</div><div class="line">2.classpath &apos;com.android.tools.build:gradle:3.0.1&apos;</div><div class="line">3.distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</div><div class="line">上面几个库有版本依赖关系，不然会出现插件库里没法识别找到  com.android.tools里的代码</div></pre></td></tr></table></figure></li><li><p>编写字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可借助ASM Bytecode Viewer插件生成，然后剔除无用代码</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基于ASM的AOP编程&quot;&gt;&lt;a href=&quot;#基于ASM的AOP编程&quot; class=&quot;headerlink&quot; title=&quot;基于ASM的AOP编程&quot;&gt;&lt;/a&gt;基于ASM的AOP编程&lt;/h3&gt;&lt;h5 id=&quot;AOP是什么&quot;&gt;&lt;a href=&quot;#AOP是什么&quot; cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>win10+ubuntu18.04双硬盘系统踩坑指南</title>
    <link href="http://yoursite.com/2019/04/22/win10+ubuntu18.04%E5%8F%8C%E7%A1%AC%E7%9B%98%E7%B3%BB%E7%BB%9F%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/04/22/win10+ubuntu18.04双硬盘系统踩坑指南/</id>
    <published>2019-04-22T05:53:00.000Z</published>
    <updated>2019-04-22T07:24:09.448Z</updated>
    
    <content type="html"><![CDATA[<p>因为学习需要，打算在家里的台式机原有的win10系统上再安装一个ubuntu系统，于是马上下单了一块固态，本以为安装双系统应该分分钟的事，可是事实证明没这么简单。</p><h3 id="1-加装固态硬盘"><a href="#1-加装固态硬盘" class="headerlink" title="1.加装固态硬盘"></a>1.加装固态硬盘</h3><p>以前刚工作时比较拮据，配电脑的时候就装了一个250g固态，虽然日常需求已经可以满足了，但是如果要在原来已经分区的情况下再去压缩几十g给ubuntu,那就远远不够了，毕竟电脑上还是会储存一些私人的资料，总不能都格式化或者迁移，于是就有了加装一个固态硬盘的想法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">准备材料：</div><div class="line">1.SATA3接口固态硬盘</div><div class="line">2.SATA3硬盘数据线(买固态一般是不赠送数据线，所以这个要自己单独买，网上顺道买就是，</div><div class="line">千万不要像我一样跑去实体店里，结果给了一g跟烂线，耽误了好些时间)</div><div class="line">3.硬盘电源线(一般我们配置的主机都会留有多余的电源线接口，在机箱里找找就行)</div><div class="line">其它注意事项：有些教程上说要开启ACH模式，4k对齐，我这里主板默认就是开启的，这步略过</div></pre></td></tr></table></figure></p><h3 id="2-制作U盘启动盘"><a href="#2-制作U盘启动盘" class="headerlink" title="2.制作U盘启动盘"></a>2.制作U盘启动盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">准备工具：</div><div class="line">1.refus (https://rufus.ie/)</div><div class="line">2.ubuntu iso(https://www.ubuntu.com/download/desktop)</div><div class="line">制作：</div><div class="line">1.安装refus,一直点next.</div><div class="line">2.选择U盘(最好是低速盘)，ubuntu.iso镜像选择</div><div class="line">3.分区类型选择(可以右键计算机-&gt;管理-&gt;磁盘管理-&gt;属性-&gt;卷查看自己磁盘是GPT还是MBR.我这里选择MBR)</div><div class="line">4.上面配置完成，点击开始等待即可</div><div class="line"></div><div class="line">其它注意事项：</div><div class="line">1.如果磁盘是MBR类型，则我们需要使用传统BIOS引导，而不是UEFI，不然安装过程中会出错或者无法启动</div><div class="line">(refus这里选择MBR类型会自动生成传统BIOS启动和UEFI启动两种方式,到时u盘启动会有两个启动项，</div><div class="line">我们直接选择哪个没有UEFI标识的项目启动安装就行)</div></pre></td></tr></table></figure><p>参考链接：</p><p>1.<a href="https://blog.csdn.net/ifreewolf_csdn/article/details/81330921" target="_blank" rel="external">refus制作启动盘</a><br>2.<a href="https://www.cnblogs.com/phyking/p/4456603.html" target="_blank" rel="external">UEFI和BIOS</a></p><h3 id="3-硬盘准备"><a href="#3-硬盘准备" class="headerlink" title="3.硬盘准备"></a>3.硬盘准备</h3><p>如果是新装的硬盘，一般不需要格式化等操作，但是如果我们第一次安装失败等情况，我们最好是将磁盘进行一次格式化还原操作，这里我们可以下载分区大师，将磁盘进行格式化，删除分区操作，做完这些我们可以进入我的电脑的磁盘管理界面查看我们刚安装的硬盘是否都变成未分配了，如果状态没有及时更新，我们可以右键及时刷新一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意事项：我们这里是在win10的环境下安装ubuntu,有很多博客都会讲到在一个引导问题，</div><div class="line">即新安装的ubuntu在另一块硬盘，导致开机的时候自动进入win10,无法进入ubuntu系统</div><div class="line">有些博主的做法是在Windows所在盘中分一个区，然后将ubuntu系统的/boot分区安装到Windows分的这个区中，</div><div class="line">即可解决问题，但是我尝试了这种做法没有成功，可能跟安装的系统版本或者uefi启动安装的类型有关，所以本文未采用上述的这种方法</div></pre></td></tr></table></figure><h3 id="4-安装系统"><a href="#4-安装系统" class="headerlink" title="4.安装系统"></a>4.安装系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.u盘启动，我这里是直接F12就会提示启动项，会出现两个u盘启动项，一个标识的是uefi，</div><div class="line">一个没有标识，我们这里选择没有标识的启动项(部分主板可能不支持直接选择，这个时候需要你到dos里直接改成上面说的这个启动项)</div><div class="line">2.选择语言(这里暂时选中文，因为出错了好歹有个提示能看得懂)，等一会儿，我们直接选择 try install ubutu,</div><div class="line">进入到ubuntu系统直接点击桌面的install ubuntu</div><div class="line">3.选择 normal installation （可选安装时获取更新）</div><div class="line">4.分区，点击+号依次添加分区(怎么分区可以看后面问题解决附带的分区指导)，然后选择 启动引导分区为 挂载点/boot的分区</div></pre></td></tr></table></figure><h3 id="4-引导修复"><a href="#4-引导修复" class="headerlink" title="4.引导修复"></a>4.引导修复</h3><p>不出意外的话，我们安装系统成功，并重启进入了我们原生的win10系统，这个时候我们是没办法直接进入ubuntu系统的，我们可以下载一个easyBCD的软件修复引导</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1.下载easyBCD安装</div><div class="line">2.添加条目，选择GRUB2类型，选择安装时的/boot分区</div><div class="line">3.编辑引导菜单-&gt;保存</div><div class="line">4.然后重启电脑就可以进入ubuntu系统了</div></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>无法将grub-efi-amd64-signed软件包安装到/target</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.这个是因为ubuntu自己的bug，我们可以在安装的时候选择 “安装时更新” 进行修复</div><div class="line"></div><div class="line">2.如果选择了“安装时更新”还是会出现这个问题，则应该是分区的问题，在uefi启动的引导里需要我们分配一个efi的区，下面列出分区信息</div><div class="line">[</div><div class="line">1. 容量:20480   主分区    起始位置 ext4日志文件系统   挂载点：/</div><div class="line">2. 容量：10480  逻辑分区  起始位置 交换文件系统swap   挂载点：无</div><div class="line">3. 容量：20480  逻辑分区  起始位置  ext4日志文件系统  挂载点：/boot</div><div class="line">4. 容量：10480  逻辑分区  起始位置  efi文件系统       挂载点：无</div><div class="line">5. 容量：全部   逻辑分区  起始位置  ext4日志文件系统  挂载点：/home</div><div class="line">] 注意：如果不是uefi启动的，则应该分区这里是没用efi文件系统的，</div><div class="line">而且这里还有一个大坑，就是你的机器可能不支持ext4文件系统，此时就需要换成ext3日志文件系统</div></pre></td></tr></table></figure><ul><li>安装完成启动ubuntu，卡黑屏而且左上角光标一直在闪烁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个一般是在装双系统，自己设置的启动引导的问题，我们一般采用的easyBCD软件来设置，这里注意，我们选择类型的时候应该选择GRUB2，然后驱动器选择自己安装系统分区 /boot 的这个分区</div></pre></td></tr></table></figure><ul><li>安装完全启动ubuntu,卡在GRUB命令行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这个问题就比较复杂了，我先说一下我的解决办法。</div><div class="line">1.我的硬盘是MBR类型的，所以我选的BIOS+MBR来安装系统</div><div class="line">2.我的电脑不支持ext4日志文件系统，我在分区的时候 /,/home,/boot都选择ext3日志文件系统(ext3分区的时候需要把 挂载点“/”放在最后分)</div><div class="line">3.easyBCD选择GRUB2方式</div></pre></td></tr></table></figure><ul><li>安装过程中提示 还原应用失败…</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">虽然这个错误不影响全局，但是强迫症不能忍，</div><div class="line">发生这个错误的原因可能是下面其中的一个</div><div class="line">1.安装的硬盘没有格式化(没有恢复到“未分配”这种状态)</div><div class="line">2.制作的启动硬盘有问题(尽量用refus来制作，并且尽量用低速磁盘即usb2.0)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为学习需要，打算在家里的台式机原有的win10系统上再安装一个ubuntu系统，于是马上下单了一块固态，本以为安装双系统应该分分钟的事，可是事实证明没这么简单。&lt;/p&gt;
&lt;h3 id=&quot;1-加装固态硬盘&quot;&gt;&lt;a href=&quot;#1-加装固态硬盘&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Maven仓库配置</title>
    <link href="http://yoursite.com/2018/10/20/Maven%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/20/Maven仓库配置/</id>
    <published>2018-10-20T15:53:00.000Z</published>
    <updated>2018-11-26T10:49:59.338Z</updated>
    
    <content type="html"><![CDATA[<p>本文会介绍三种开发中可用的仓库配置</p><ul><li>本地仓库</li><li>局域网仓库</li><li>JCenter仓库<h4 id="一、本地仓库"><a href="#一、本地仓库" class="headerlink" title="一、本地仓库"></a>一、本地仓库</h4></li></ul><p>1.配置需要生成仓库的module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;maven&apos;</div><div class="line"></div><div class="line">uploadArchives&#123;</div><div class="line">    repositories.mavenDeployer&#123;</div><div class="line">        // 配置本地仓库路径，项目根目录下的repository目录中</div><div class="line">        repository(url: uri(&apos;../repository&apos;))</div><div class="line">        pom.groupId = &quot;com.rolan.eventplugin&quot;// 唯一标识（通常为模块包名，也可以任意）</div><div class="line">        pom.artifactId = &quot;eventplugin&quot; // 项目名称（通常为类库模块名称，也可以任意）</div><div class="line">        pom.version = &quot;1.0.0&quot; // 版本号</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-----或者以下这种方式</div><div class="line">apply plugin: &apos;maven-publish&apos;</div><div class="line">publishing &#123;</div><div class="line">    publications &#123;</div><div class="line">        mavenJava(MavenPublication) &#123;</div><div class="line">            groupId &apos;com.rolan.eventplugin&apos;</div><div class="line">            artifactId &apos;eventplugin&apos;</div><div class="line">            version &apos;1.0.0&apos;</div><div class="line">            from components.java</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">publishing &#123;</div><div class="line">    repositories &#123;</div><div class="line">        maven &#123;</div><div class="line">            // change to point to your repo, e.g. http://my.org/repo</div><div class="line">            url uri(&apos;../maven&apos;)//发布到本地目录中</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./gradlew publish</div><div class="line"></div><div class="line">或者可以点击AndroidStudio右边的build中的uploadArchives选项</div></pre></td></tr></table></figure><p>3.使用<br>  经过第二个步骤会在指定的目录下生成仓库，上面我们指定了项目的根目录下的maven<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  //这里是插件编写的使用方式 如果是module.参考第二种或者第三种使用方法</div><div class="line">【project/build.gradle】</div><div class="line"> classpath &apos;com.rolan.eventplugin:eventplugin:1.0.0&apos;</div><div class="line"> </div><div class="line"> </div><div class="line">【app/build.gradle】</div><div class="line">apply plugin: com.rolan.eventplugin.EventStonePlugin//需要写包名+类名</div></pre></td></tr></table></figure></p><h4 id="二、局域网仓库"><a href="#二、局域网仓库" class="headerlink" title="二、局域网仓库"></a>二、局域网仓库</h4><ul><li><p>下载Nexus3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https://www.sonatype.com/download-oss-sonatype</div><div class="line">选择系统对应版本的maven管理</div></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mac:</div><div class="line"></div><div class="line">  nexus.properties:配置相关属性</div><div class="line">  ./nexus-2.11.3-01/bin/nexus start 启动服务</div><div class="line">  </div><div class="line">Windows：</div><div class="line">   1.解压，选择不同操作系统对应的目录，如：nexus-2.14.8-01-bundle\nexus-2.14.8-01\bin\jsw\windows-x86-64</div><div class="line">   </div><div class="line">   2.点击console-nexus.bat启动nexus</div></pre></td></tr></table></figure></li><li><p>管理</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:8081/nexus</div><div class="line">默认账号：admin/admin123</div></pre></td></tr></table></figure><ul><li>发布</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;maven&apos;</div><div class="line">task androidSourcesJar(type: Jar) &#123;//打包main目录下代码和资源的 task</div><div class="line">    classifier = &apos;sources&apos;</div><div class="line">    from android.sourceSets.main.java.srcDirs</div><div class="line">&#125;</div><div class="line"></div><div class="line">artifacts &#123;//配置需要上传到maven仓库的文件</div><div class="line">    archives androidSourcesJar</div><div class="line">&#125;</div><div class="line"></div><div class="line">uploadArchives &#123;//上传到Maven仓库的task</div><div class="line">    repositories &#123;</div><div class="line">        mavenDeployer &#123;</div><div class="line">            //指定maven仓库url</div><div class="line">            repository(url: &quot;http://localhost:8081/nexus/content/repositories/releases/&quot;) &#123;</div><div class="line">            //nexus登录默认用户名和密码</div><div class="line">            authentication(userName: &quot;admin&quot;, password: &quot;admin123&quot;)</div><div class="line">            &#125;</div><div class="line">            pom.groupId = &quot;com.rolan.eventplugin&quot;</div><div class="line">            pom.artifactId = &quot;eventplugin&quot; ）</div><div class="line">            pom.version = &quot;1.0.0&quot; // 版本号</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">        maven &#123; </div><div class="line">            url &apos;http://localhost:8081/nexus/content/repositories/releases/&apos; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">implementation &apos;com.rolan.eventplugin:eventplugin:1.0.0&apos;</div></pre></td></tr></table></figure></li></ul><h4 id="二、发布到JCenter"><a href="#二、发布到JCenter" class="headerlink" title="二、发布到JCenter"></a>二、发布到JCenter</h4><ul><li><p>注册账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://bintray.com  这里要注册开发者账号 不要注册企业账号</div></pre></td></tr></table></figure></li><li><p>创建组织(create organizations)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">组织id: jyblife</div><div class="line">组织名称：jyb</div></pre></td></tr></table></figure><ul><li><p>创建maven仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name:maven 写死maven</div><div class="line">仓库类型选择maven</div></pre></td></tr></table></figure></li><li><p>add new package</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name:eventplugin 对应后面publish里面的artifactId</div><div class="line">version control: 0.0.1</div></pre></td></tr></table></figure></li><li><p>项目配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">classpath &apos;com.novoda:bintray-release:0.9&apos;</div><div class="line"></div><div class="line">apply plugin: &apos;com.novoda.bintray-release&apos;</div><div class="line"></div><div class="line">publish &#123;</div><div class="line">    userOrg = &apos;组织ID&apos; </div><div class="line">    groupId = &apos;com.rolan.eventplugin&apos; </div><div class="line">    artifactId = &apos;eventplugin&apos; //项目名称 上面add new package中的name</div><div class="line">    publishVersion = &apos;1.0.2&apos; //版本号</div><div class="line">    desc = &apos;&apos; </div><div class="line">    website = &apos;&apos; //项目主页，可以不写</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">    google()</div><div class="line">    jcenter()</div><div class="line">    maven &#123; url &apos; https://dl.bintray.com/jyblife/maven&apos; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">implementation &apos;com.rolan.eventplugin:eventplugin:1.0.0&apos;</div></pre></td></tr></table></figure></li><li><p>常见错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.HTTP/1.1 404 Not Found</div><div class="line">这个一般是 add new package中的name和publish中的artifactId不一致</div><div class="line"></div><div class="line">2.按build提示关掉 lint</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文会介绍三种开发中可用的仓库配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地仓库&lt;/li&gt;
&lt;li&gt;局域网仓库&lt;/li&gt;
&lt;li&gt;JCenter仓库&lt;h4 id=&quot;一、本地仓库&quot;&gt;&lt;a href=&quot;#一、本地仓库&quot; class=&quot;headerlink&quot; title=&quot;一、本地仓库&quot;&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件编写与发布和动态修改字节码</title>
    <link href="http://yoursite.com/2018/09/06/gradleplugin/"/>
    <id>http://yoursite.com/2018/09/06/gradleplugin/</id>
    <published>2018-09-06T10:36:00.000Z</published>
    <updated>2018-09-06T10:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="GradlePlugin"><a href="#GradlePlugin" class="headerlink" title="GradlePlugin"></a>GradlePlugin</h1><p>插件可分为三种方式编写，每种方式各有利弊，根据业务逻辑选择</p><ul><li>Build Script</li><li>BuildSrc Project</li><li>Standalone project</li><li>动态获取配置</li><li>修改字节码文件</li></ul><p>在大多数情况下，我们都是用groovy来编写插件，因为groovy更简洁优雅，如果你不喜欢或是不太熟悉groovy，你也可以用java实现，插件编写支持groovy和java或者kotlin同时混编</p><h3 id="Build-Script"><a href="#Build-Script" class="headerlink" title="Build Script"></a>Build Script</h3><p>在模块的build.gradle直接编写脚本代码，仅限于当前moudle,不利于复用</p><ul><li><p>在模块的build.gradle直接创建一个plugin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 只可在module的build.gradle定义的plugin</div><div class="line"> */</div><div class="line">class helloWorldPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        project.task(&apos;build-hello&apos;) &#123;//tasks名称</div><div class="line">            group = &quot;android&quot;//tasks所在的组</div><div class="line">            description = &quot;gradle build script demo,shares only in this build.gradle&quot;</div><div class="line">            doLast &#123;</div><div class="line">                println &quot;Hello from the BuildScriptPlugin&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>当前module下build.gradle apply</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: helloWorldPlugin</div></pre></td></tr></table></figure></li></ul><h3 id="BuildSrc-Project"><a href="#BuildSrc-Project" class="headerlink" title="BuildSrc Project"></a>BuildSrc Project</h3><p>在项目建立一个gradle默认会编译的路径，整个项目的moudled都可通用</p><ul><li>创建’rootProjectDir/buildSrc/src/main/groovy’</li><li>编写源码</li><li>apply<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: com.rolan.ProjectBuild//需要写包名+类名</div></pre></td></tr></table></figure></li></ul><h3 id="Standalone-project"><a href="#Standalone-project" class="headerlink" title="Standalone project"></a>Standalone project</h3><ul><li><p>创建一个Android Module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.删除除src/main build.gradle文件外所有内容</div><div class="line">2.清空build.gradle</div><div class="line">3.创建 src/main/groovy/包名 目录</div><div class="line">4.创建 src/main/resources/META-INF/gradle-plugins/com.rolan.eventplugin.EventStone.properties //包名+</div></pre></td></tr></table></figure></li><li><p>添加groovy语言支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;groovy&apos;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    //gradle sdk</div><div class="line">    compile gradleApi()</div><div class="line">    //groovy sdk</div><div class="line">    compile localGroovy()</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>编写插件代码</p></li><li>发布</li></ul><p>1.build.gradle添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;maven-publish&apos;</div><div class="line"></div><div class="line">publishing &#123;</div><div class="line">    publications &#123;</div><div class="line">        mavenJava(MavenPublication) &#123;</div><div class="line">            groupId &apos;com.rolan.eventplugin&apos;</div><div class="line">            artifactId &apos;eventplugin&apos;</div><div class="line">            version &apos;1.0.0&apos;</div><div class="line">            from components.java</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">publishing &#123;</div><div class="line">    repositories &#123;</div><div class="line">        maven &#123;</div><div class="line">            // change to point to your repo, e.g. http://my.org/repo</div><div class="line">            url uri(&apos;../maven&apos;)//发布到本地目录中</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2.gradlew publish 发布<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意：记得发布或者升级版本之前不要配置了项目的 classpath,不然会发布错误</div></pre></td></tr></table></figure></p><p>3.依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">【project/build.gradle】</div><div class="line"></div><div class="line"> classpath &apos;com.rolan.eventplugin:eventplugin:1.0.0&apos;</div><div class="line"> </div><div class="line"> </div><div class="line">【app/build.gradle】</div><div class="line"></div><div class="line">apply plugin: com.rolan.eventplugin.EventStonePlugin//需要写包名+类名</div></pre></td></tr></table></figure></p><h3 id="动态获取配置"><a href="#动态获取配置" class="headerlink" title="动态获取配置"></a>动态获取配置</h3><p>  我们经常能看到第三方的项目会要求在build.gradle配置一些参数，这些参数有什么作用，怎么获取</p><ul><li>参数编写<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class ProjectExtension &#123;//这里首字母一定要大写</div><div class="line">    String name = null</div><div class="line">    String version = null</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ModuleConfig &#123;</div><div class="line">    String name = null</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>参数获取与关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//关联</div><div class="line">project.extensions.create(&apos;project_config&apos;, ProjectExtension)//这里会关联到build.gradle中配置的参数</div><div class="line">project_config&#123;&#125;</div><div class="line">       project.extensions.create(&apos;module_config&apos;, ModuleConfig)</div><div class="line">       </div><div class="line">//获取       </div><div class="line">def project_config=project[&apos;project_config&apos;]</div><div class="line">def module_config=project[&apos;module_config&apos;]</div><div class="line"></div><div class="line">println &quot;project_config name:&quot;+project_config.name</div><div class="line">println &quot;project_config version:&quot;+project_config.version</div></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">apply plugin: com.rolan.ProjectBuild//需要写包名+类名</div><div class="line">------------&gt;这下面两种方式都可以</div><div class="line">project_config&#123;</div><div class="line">    name &quot;GradlePlugin&quot;</div><div class="line">    version &quot;0.0.1&quot;</div><div class="line">    module_config&#123;</div><div class="line">        name &quot;buildSrc module&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">project_config&#123;</div><div class="line">    name &quot;GradlePlugin&quot;</div><div class="line">    version &quot;0.0.1&quot;</div><div class="line">&#125;</div><div class="line">module_config&#123;</div><div class="line">         name &quot;buildSrc module&quot;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></li></ul><h3 id="修改字节码文件"><a href="#修改字节码文件" class="headerlink" title="修改字节码文件"></a>修改字节码文件</h3><ul><li><p>Transform的简要书写</p><p>这里暂时没有对字节码文件做修改操作，而是将输入转给了输出，这是必须得基本步骤，因为Transform是一个串联的操作，<br>必须有输入和输出，不然会中断编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">class EventTransform extends Transform &#123;</div><div class="line"></div><div class="line">    private Project project</div><div class="line"></div><div class="line">    EventTransform(Project project) &#123;</div><div class="line">        this.project = project</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    String getName() &#123;//tasks 名称</div><div class="line">        return &quot;EventStonePlugin&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;//处理的文件类型</div><div class="line">        return TransformManager.CONTENT_CLASS</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;//指定task 作用范围</div><div class="line">        return TransformManager.SCOPE_FULL_PROJECT</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    boolean isIncremental() &#123;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</div><div class="line">        super.transform(transformInvocation)</div><div class="line">        transformInvocation.inputs.each &#123;</div><div class="line">            it.jarInputs.each &#123;//对类型为jar文件的input进行遍历[第三方依赖]</div><div class="line">                println &quot;*******file_path jarInputs********&quot; + it.file.absolutePath</div><div class="line">                def jarName = it.name</div><div class="line">                def md5Name = DigestUtils.md5Hex(it.file.getAbsolutePath())</div><div class="line">                if (jarName.endsWith(&quot;.jar&quot;)) &#123;</div><div class="line">                    jarName = jarName.substring(0, jarName.length() - 4)</div><div class="line">                &#125;</div><div class="line">                // 获取output目录</div><div class="line">                def dest = transformInvocation.outputProvider.getContentLocation(</div><div class="line">                        jarName + md5Name, it.contentTypes, it.scopes, Format.JAR)</div><div class="line">                FileUtils.copyFile(it.file, dest)</div><div class="line">            &#125;</div><div class="line">            it.directoryInputs.each &#123;</div><div class="line">                //对类型为“文件夹”的input进行遍历[包含书写的类以及R.class、BuildConfig.class以及R$XXX.class等]</div><div class="line">                println &quot;*******file_path directoryInputs********&quot; + it.file.absolutePath</div><div class="line">                // 获取output目录</div><div class="line">                def dest = transformInvocation.outputProvider.getContentLocation(</div><div class="line">                        it.name,</div><div class="line">                        it.contentTypes,</div><div class="line">                        it.scopes,</div><div class="line">                        Format.DIRECTORY)</div><div class="line">                FileUtils.copyDirectory(it.file, dest)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在Plugin中注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void apply(Project project) &#123;</div><div class="line">        project.android.registerTransform(new EventTransform(project))</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>操作class文件</p><p>1.迭代文件夹目录，找出需要修改的class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> void injectCodeByDir(String path, String rootPath)&#123;</div><div class="line">        try &#123;</div><div class="line">            pool.insertClassPath(path);</div><div class="line">        &#125; catch (NotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        File dir = new File(path);</div><div class="line">        listFiles(dir,rootPath);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void listFiles(File dir,String rootPath) &#123;</div><div class="line">        if (dir.isDirectory()) &#123;</div><div class="line">           for(File file:dir.listFiles())&#123;</div><div class="line">               listFiles(file, rootPath);</div><div class="line">           &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            injectCode(dir,rootPath);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void injectCode(File file,String rootPath) &#123;</div><div class="line">        String filePath = file.getAbsolutePath();</div><div class="line">        if (filePath.endsWith(&quot;.class&quot;)</div><div class="line">                &amp;&amp; !filePath.contains(&quot;R$&quot;)</div><div class="line">                &amp;&amp; !filePath.contains(&quot;R.class&quot;)</div><div class="line">                &amp;&amp; !filePath.contains(&quot;BuildConfig.class&quot;)) &#123;</div><div class="line">            println(&quot;****class file****&quot;+filePath);</div><div class="line">            int index = FileUtil.isSamePackage(filePath, packageName);</div><div class="line">            if(index!=-1)&#123;//未设置packageName默认不检查返回true</div><div class="line">                println(&quot;***************--------***************&quot;+filePath);</div><div class="line">                String className = filePath.substring(index, filePath.length() - 6)</div><div class="line">                        .replace(&apos;\\&apos;, &apos;.&apos;).replace(&apos;/&apos;, &apos;.&apos;);</div><div class="line">                println(&quot;***************----className----***************&quot;+className);</div><div class="line">//                addConstructorMethod(rootPath, className);</div><div class="line">                injectMethod(rootPath,className);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>2.为所有类添加构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void addConstructorMethod(String rootPath, String className) &#123;</div><div class="line">       CtClass ctClass = null ;</div><div class="line">       try &#123;</div><div class="line">           ctClass = pool.getCtClass(className);</div><div class="line"> </div><div class="line">           if (ctClass.isFrozen()) &#123;</div><div class="line">               ctClass.defrost();</div><div class="line">           &#125;</div><div class="line">           String body = &quot;System.out.println(\&quot;构造方法\&quot; ); &quot;;</div><div class="line">           CtConstructor[] cts = ctClass.getDeclaredConstructors();</div><div class="line">           if (cts == null || cts.length == 0) &#123;</div><div class="line">               //手动创建一个构造函数</div><div class="line">               CtConstructor constructor = new CtConstructor(new CtClass[0], ctClass);</div><div class="line">               constructor.insertBeforeBody(body);</div><div class="line">               ctClass.addConstructor(constructor);</div><div class="line">           &#125; else &#123;</div><div class="line">               cts[0].insertBeforeBody(body);</div><div class="line">           &#125;</div><div class="line">           ctClass.writeFile(rootPath);</div><div class="line">           ctClass.detach();</div><div class="line">       &#125; catch (Exception e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>3.修改已有方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void injectMethod(String rootPath,String className) &#123;</div><div class="line">        try &#123;</div><div class="line">            CtClass ctClass = pool.get(className);</div><div class="line">            if (ctClass.isFrozen()) &#123;</div><div class="line">                ctClass.defrost();</div><div class="line">            &#125;</div><div class="line">            for (CtMethod ctmethod : ctClass.getDeclaredMethods()) &#123;</div><div class="line">                String methodName = FileUtil.getSimpleName(ctmethod);</div><div class="line">                println(&quot;----method----&quot;+methodName);</div><div class="line">                if(&quot;onClick&quot;.equals(methodName))&#123;</div><div class="line">                    String body = &quot;System.out.println(\&quot;加入的方法\&quot; ); &quot;;</div><div class="line">                    CtMethod method = ctClass.getDeclaredMethod(&quot;onClick&quot;,new CtClass[]&#123;pool.get(&quot;android.view.View&quot;)&#125;);</div><div class="line">                    method.insertAfter(body);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ctClass.writeFile(rootPath);</div><div class="line">            ctClass.detach();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>4.注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">project.android.bootClasspath.each &#123;//这里会将android sdk插入进去，因为如果下面需要get android里的类，不然会报notFoundExcetion</div><div class="line">            println &quot;android absolutePath: &quot; + it.absolutePath</div><div class="line">            pool.appendClassPath(it.absolutePath)</div><div class="line">        &#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;GradlePlugin&quot;&gt;&lt;a href=&quot;#GradlePlugin&quot; class=&quot;headerlink&quot; title=&quot;GradlePlugin&quot;&gt;&lt;/a&gt;GradlePlugin&lt;/h1&gt;&lt;p&gt;插件可分为三种方式编写，每种方式各有利弊，根据业务
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>日常纪要之01</title>
    <link href="http://yoursite.com/2018/07/04/%E6%97%A5%E5%B8%B8%E7%BA%AA%E8%A6%8101/"/>
    <id>http://yoursite.com/2018/07/04/日常纪要01/</id>
    <published>2018-07-04T12:57:00.000Z</published>
    <updated>2018-07-04T13:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>写了删 删了写 </p><p>you</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写了删 删了写 &lt;/p&gt;
&lt;p&gt;you&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>阿里云Nginx+uwsgi+Django云服务搭建</title>
    <link href="http://yoursite.com/2018/06/25/django/"/>
    <id>http://yoursite.com/2018/06/25/django/</id>
    <published>2018-06-25T12:36:00.000Z</published>
    <updated>2018-06-26T02:46:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文旨在概述搭建一个具有负载均衡，高并发的django服务器的流程，包含环境准备到发布到云服务器及其一些细节的处理，并不包含django服务器的开发(可自行查阅资料),因为笔者大量查阅过<br>网上一些教程，这方面的资料虽然很多，但是很多都会误导新手，而且其中更是错误百出，残差不齐，所以就有了这篇文章，把整个发布的流程记录下来，然而也不敢说此文没有一点错误，这错误会因每个人的生成环境的不一致而有不同的体现，倘若有些错误也是有益的，因为编程本来就是一个不断试错的过程，牛人之所以牛，无非就是踩过的坑比你多而已。</p><ul><li>非常强调:</li></ul><p>==不要使用Python3!==</p><p>==不要使用Python3!==</p><p>==不要使用Python3!==</p><p>如果你要问我原因，我只能说现在远离它，一身轻松，</p><p>==人生苦短，我用python2==</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>阿里云服务器一台 ubuntu16.04,本地mac一台</p></li><li><p>连接服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@120.78.181.212  然后输入密码</div></pre></td></tr></table></figure></li><li><p>上传项目文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">目录要提前建好</div><div class="line">1.sudo scp -r /Users/wangyang/python/django_demo root@120.78.181.212:/root/python/django_demo</div><div class="line">2.通过上传至第三方仓库下载(github)</div></pre></td></tr></table></figure><ul><li><p>pip安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-pip</div></pre></td></tr></table></figure></li><li><p>Mysql 安装</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-server</div><div class="line"> </div><div class="line">apt-get install mysql-client</div><div class="line"> </div><div class="line">sudo apt-get install libmysqlclient-dev</div></pre></td></tr></table></figure><hr><ul><li>搭建虚拟环境</li></ul><p>安装virtualenvwrapper(基于virtualenv的管理器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install virtualenvwrapper</div></pre></td></tr></table></figure><p>查看python命令路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">which python     -&gt; /usr/bin/python</div><div class="line">which python3    -&gt; /usr/bin/python3</div></pre></td></tr></table></figure></p><p>配置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">=&gt;Mac</div><div class="line">1.在.bash_profile中加入  </div><div class="line">export WORKON_HOME=&apos;~/.virtualenvs&apos;</div><div class="line">source /usr/local/bin/virtualenvwrapper.sh</div><div class="line">2.source .bash_profile</div><div class="line">=&gt;Ubutu</div><div class="line">1.在.bashrc中加入</div><div class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7 # 这句是为了防止环境变量$PATH中已有其它环境的python，需要换成自己需要的python路径</div><div class="line">export WORKON_HOME=$HOME/.virtualenvs # 放所有虚拟环境的地方</div><div class="line">source /usr/local/bin/virtualenvwrapper.sh</div><div class="line">2.source .bashrc</div></pre></td></tr></table></figure></p><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mkvirtualenv py2  创建环境</div><div class="line">mkvirtualenv --python=/usr/local/python3.5.3/bin/python py2  创建环境</div><div class="line"></div><div class="line">workon 查看当前</div><div class="line"></div><div class="line">workon py2  应用环境</div><div class="line"></div><div class="line">deactivate  退出虚拟环境</div><div class="line"></div><div class="line">rmvirtualenv py2 删除虚拟环境</div></pre></td></tr></table></figure><ul><li><p>依赖安装</p><p>1.首先在本地机器 项目生产依赖目录文件(上传项目前完成)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip freeze&gt;requirements.txt</div></pre></td></tr></table></figure></li></ul><p>2.在某一环境下安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -r requirements.txt</div></pre></td></tr></table></figure><p>3.创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p****** 进入shell</div><div class="line">show databases; 显示全部数据库</div><div class="line">create database tiantian; 创建数据库</div></pre></td></tr></table></figure><p>4.迁移数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python manage.py makemigrations</div><div class="line">python manage.py migrate</div></pre></td></tr></table></figure></p><h4 id="配置项目文件"><a href="#配置项目文件" class="headerlink" title="配置项目文件"></a>配置项目文件</h4><ul><li><p>修改setting.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALLOWED_HOSTS = [&apos;*&apos;, ]</div></pre></td></tr></table></figure></li><li><p>运行项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py runserver 0:8000</div></pre></td></tr></table></figure></li><li><p>访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在浏览器中输入自己服务器对公ip访问</div><div class="line"> 对公ip:8000</div></pre></td></tr></table></figure></li><li><p>错误解决（不能访问）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.检查防火墙</div><div class="line"> </div><div class="line">sudo ufw status # 检查防火墙状态</div><div class="line">sudo ufw disable  # 可以临时关闭防火墙</div><div class="line">sudo ufw allow 8000 # 或者保持防火墙开启，允许8000端口连接</div><div class="line"></div><div class="line">2.服务器安全组规则</div><div class="line">  添加规则： 授权对象 0.0.0.0/0 </div><div class="line">  端口范围 7000/8111</div></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">确认正常后，打开setting.py</div><div class="line">DEBUG=False</div></pre></td></tr></table></figure></li></ul><h4 id="配置uwsgi"><a href="#配置uwsgi" class="headerlink" title="配置uwsgi"></a>配置uwsgi</h4><ul><li>安装uwsgi</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install uwsgi</div></pre></td></tr></table></figure><ul><li><p>检查uwsgi服务是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">创建一个test.py</div><div class="line">def application(env, start_response):</div><div class="line">    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;,&apos;text/html&apos;)])</div><div class="line">    return [&quot;Hello World&quot;]  # python2</div><div class="line">    # return [b&quot;Hello World&quot;]  # python3</div><div class="line">    </div><div class="line">uwsgi --http :8000 --wsgi-file test.py 运行</div><div class="line">127.0.0.1：8000  访问成功则表示服务正常</div></pre></td></tr></table></figure></li><li><p>uwsgi 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">项目文件下创建 uwsgi.ini文件</div><div class="line">[uwsgi]</div><div class="line"># socket = 0:8001 # 使用nginx连接时使用</div><div class="line">http = 0:8080 # 直接做web服务器使用</div><div class="line"></div><div class="line"># 项目目录</div><div class="line">chdir = /root/django_demo</div><div class="line"># 项目中wsgi.py文件的目录</div><div class="line">wsgi-file = /root/django_demo/wsgi.py</div><div class="line"># 主进程</div><div class="line">master = true</div><div class="line"># 多进程&amp;多线程</div><div class="line">processes = 6</div><div class="line">threads = 2</div><div class="line">pidfile=uwsgi.pid #可用来停止服务</div></pre></td></tr></table></figure></li><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uwsgi --ini uwsgi.ini 开启服务</div><div class="line">uwsgi --stop uwsgi.pid 停止服务</div><div class="line">ps ajx|grep uwsgi  查看进程信息</div><div class="line">pkill -f -9 uwsgi  强制停止uwsgi</div></pre></td></tr></table></figure></li></ul><h4 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h4><ul><li>安装nginx</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在项目目录下运行下面命令 ，将uwsgi_params拷贝到项目文件夹下</div><div class="line">cp /etc/nginx/uwsgi_params .</div></pre></td></tr></table></figure><ul><li><p>创建 my.nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">upstream django &#123;</div><div class="line">    server    127.0.0.1:8001;</div><div class="line">    # server      unix://home/python/Desktop/project_test/my_sock.sock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen      8000;  # 端口号</div><div class="line">    server_name 127.0.0.1;  # 服务器 ip 或是域名</div><div class="line">    charset     utf-8;  # 字符集</div><div class="line"></div><div class="line">    # 最大上传限制</div><div class="line">    # client_max_body_size 75M;</div><div class="line"></div><div class="line">    location /media  &#123;</div><div class="line">        alias /home/python/Desktop/project_test/media_common;  # 媒体文件所在文件夹</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /static &#123;</div><div class="line">        alias /home/python/Desktop/project_test/static_common;  # 静态文件所在文件夹</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    # 将所有非媒体请求转到Django服务器上</div><div class="line">    location / &#123;</div><div class="line">        uwsgi_pass      django;  # 最上方已定义</div><div class="line">        # 将所有参数都转到uwsgi下</div><div class="line">        include         /home/python/Desktop/project_test/uwsgi_params; # uwsgi_params的路径</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>建立软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /root/django_demo/my_nginx.conf /etc/nginx/sites-enabled/</div></pre></td></tr></table></figure></li><li><p>创建静态文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">先获取目录权限 chmod 666 /root/django_demo</div><div class="line">创建文件夹</div><div class="line"> mkdir static_common</div><div class="line"> mkdir media_common</div></pre></td></tr></table></figure></li><li><p>修改项目setting.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注释掉 STATIC</div><div class="line">STATIC_ROOT = os.path.join(BASE_DIR, &apos;static_common&apos;)</div><div class="line">MEDIA_ROOT = os.path.join(BASE_DIR, &apos;media_common&apos;)</div></pre></td></tr></table></figure></li><li><p>迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py collectstatic</div></pre></td></tr></table></figure></li><li><p>问题解决<br>静态文件加载不出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.测试 公网ip:8000/static/admin/css/base.css 是否能加载</div><div class="line"> -&gt;如果403 ，先对文件夹申请权限</div><div class="line"> -&gt;然后检查 /etc/nginx/nginx_conf 第一行</div><div class="line"> ---&gt;正确的头应该是  user  root;</div><div class="line">2.也可排查log找到具体问题</div><div class="line">  /var/log/nginx 目录下会有 access.log error.log文件，打开就可排查</div></pre></td></tr></table></figure></li></ul><h4 id="其它小问题"><a href="#其它小问题" class="headerlink" title="其它小问题"></a>其它小问题</h4><ul><li>端口占用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lsof -i:8000 列出端口占用程序</div><div class="line"></div><div class="line">netstat -ap 所有端口</div><div class="line"></div><div class="line">kill -9 PID号 杀掉程序</div></pre></td></tr></table></figure></li></ul><ul><li>vi 方向键失效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">这是因为ubuntu预装的是vim-tiny</div><div class="line">步骤一，输入下述命令以卸载vim-tiny：</div><div class="line">sudo apt-get remove vim-common</div><div class="line">步骤二，输入下述命令以安装vim-full：</div><div class="line">sudo apt-get install vim</div></pre></td></tr></table></figure><ul><li><p>ubuntu Unable to locate package</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">新系统需要  sudo apt-get update</div></pre></td></tr></table></figure></li><li><p>配置pip国内源</p></li></ul><p>国内源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">豆瓣(douban) http://pypi.douban.com/simple/ (推荐) </div><div class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ </div><div class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/ </div><div class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ </div><div class="line">中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</div></pre></td></tr></table></figure></p><p>创建 pip.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir ~/.pip</div><div class="line">cd ~/.pip</div><div class="line">touch pip.conf</div></pre></td></tr></table></figure><p>编辑pip.conf,将下面内容copy进文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[global] </div><div class="line">index-url = http://pypi.douban.com/simple </div><div class="line">[install] </div><div class="line">trusted-host=pypi.douban.com</div></pre></td></tr></table></figure></p><ul><li><p>ssh连接工具</p><p>  Mac上可安装Shuttle来进行管理连接</p><p>  Windows安装xshell</p></li></ul><p>*参考资料</p><p><a href="https://www.djangoproject.com/start/" target="_blank" rel="external">Djanog官方文档</a></p><p><a href="https://www.cnblogs.com/qingspace/p/6838747.html" target="_blank" rel="external">https://www.cnblogs.com/qingspace/p/6838747.html</a></p><p><a href="https://blog.csdn.net/m0_37887449/article/details/73086899" target="_blank" rel="external">https://blog.csdn.net/m0_37887449/article/details/73086899</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文旨在概述搭建一个具有负载均衡，高并发的django服务器的流程，包含环境准备到发布到云服务器及其一些细节的处理，并不包含django服务
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>生活感悟之努力篇</title>
    <link href="http://yoursite.com/2018/05/07/%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2018/05/07/生活/</id>
    <published>2018-05-07T12:57:00.000Z</published>
    <updated>2018-05-07T13:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>  人总是懒于改变，尤其害怕变化<br>  对比于过去<br>  我花了大学四年，工作三年<br>  才真的明白一些道理<br>  更能理解生活<br>  更加坚定努力的信念<br>  因为<br>  我确实能看到将来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  人总是懒于改变，尤其害怕变化&lt;br&gt;  对比于过去&lt;br&gt;  我花了大学四年，工作三年&lt;br&gt;  才真的明白一些道理&lt;br&gt;  更能理解生活&lt;br&gt;  更加坚定努力的信念&lt;br&gt;  因为&lt;br&gt;  我确实能看到将来&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffers使用及其源码浅析</title>
    <link href="http://yoursite.com/2018/04/24/ProtocolBuffers/"/>
    <id>http://yoursite.com/2018/04/24/ProtocolBuffers/</id>
    <published>2018-04-24T12:30:00.000Z</published>
    <updated>2018-04-27T06:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><ul><li>下载Protocol Buffers源码 <a href="https://developers.google.com/protocol-buffers/docs/javatutorial" target="_blank" rel="external">官网</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/google/protobuf.git</div></pre></td></tr></table></figure><ul><li>编译源码</li></ul><ol><li>进入protobuf/目录下</li><li>./autogen.sh </li><li>./configure </li><li>make</li><li>sudo make install</li></ol><ul><li>执行完上面步骤后即可全局执行protoc命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protoc --version  查看当前版本</div><div class="line">protoc --help     查看命令</div></pre></td></tr></table></figure><ul><li>编写 .proto文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">syntax = &quot;proto2&quot;;</div><div class="line">package protocal;</div><div class="line">option java_package = &quot;com.rolan.proto&quot;;</div><div class="line">option java_outer_classname = &quot;PersonEntity&quot;;</div><div class="line">message People &#123;</div><div class="line">    repeated Person person = 1;//可重复的，即数组</div><div class="line">    message Person &#123;</div><div class="line">        required int32 id = 1;</div><div class="line">        required int64 index = 2;</div><div class="line">        optional string guid=3;</div><div class="line">        required string name = 4;</div><div class="line">        optional string gender=5;</div><div class="line">        optional string company=6;</div><div class="line">        optional string email = 7;</div><div class="line">        repeated Friend friend = 8;</div><div class="line"></div><div class="line">        message Friend &#123;</div><div class="line">            required string id = 1;</div><div class="line">            required string name = 4;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>编译出java文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc -I=. --java_out=. addressbook.proto</div></pre></td></tr></table></figure><ul><li>java层源码支持</li></ul><p>1.可自行根据源码中protocol/java 编译出jar包<br>2.build.gradle引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &apos;com.google.protobuf:protobuf-java:3.5.1&apos;</div></pre></td></tr></table></figure><ul><li>序列化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">PersonEntity.People.Builder people = PersonEntity.People.newBuilder();</div><div class="line">       for (int i = 0; i &lt; sampleSize; i++) &#123;</div><div class="line">           PersonEntity.People.Person.Builder person = PersonEntity.People.Person.newBuilder();</div><div class="line">           PersonEntity.People.Person.Friend friend1 = PersonEntity.People.Person.Friend.newBuilder().setId(&quot;1111&quot;).setName(&quot;李四&quot;).build();</div><div class="line">           PersonEntity.People.Person.Friend friend2 = PersonEntity.People.Person.Friend.newBuilder().setId(&quot;2222&quot;).setName(&quot;张三&quot;).build();</div><div class="line">           PersonEntity.People.Person.Friend friend3 = PersonEntity.People.Person.Friend.newBuilder().setId(&quot;3333&quot;).setName(&quot;王五&quot;).build();</div><div class="line">           person.setId(i)</div><div class="line">                   .setIndex(i)</div><div class="line">                   .setGuid(&quot;guid&quot; + i)</div><div class="line">                   .setName(&quot;name:&quot; + i)</div><div class="line">                   .setGender(i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;)</div><div class="line">                   .setCompany(&quot;加油宝：&quot; + i)</div><div class="line">                   .setEmail(&quot;sd@.com&quot;)</div><div class="line">                   .addFriend(friend1)</div><div class="line">                   .addFriend(friend2)</div><div class="line">                   .addFriend(friend3)</div><div class="line">                   .build();</div><div class="line">           people.addPerson(person);</div><div class="line">       &#125;</div><div class="line">       PersonEntity.People build = people.build();</div></pre></td></tr></table></figure><ul><li>反序列化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">byte[] bytes = Utils.toByteArray(file);</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            PersonEntity.People people = PersonEntity.People.parseFrom(bytes);</div><div class="line">            PersonEntity.People.Person person = people.getPerson(1);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;下载Protocol Buffers源码 &lt;a href=&quot;https://developers.google.
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flatbuffers使用及其源码浅析</title>
    <link href="http://yoursite.com/2018/04/18/Flatbuffers/"/>
    <id>http://yoursite.com/2018/04/18/Flatbuffers/</id>
    <published>2018-04-18T11:56:00.000Z</published>
    <updated>2018-04-27T06:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要用flatbuffers-官网"><a href="#为什么要用flatbuffers-官网" class="headerlink" title="为什么要用flatbuffers 官网"></a>为什么要用flatbuffers <a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">官网</a></h4><table><thead><tr><th></th><th>FlatBuffers (binary)</th><th>Protocol Buffers LITE</th><th>Rapid JSON</th><th>FlatBuffers (JSON)</th><th>pugixml</th><th>Raw structs</th></tr></thead><tbody><tr><td>Decode + Traverse + Dealloc (1 million times, seconds)</td><td>0.08</td><td>302</td><td>583</td><td>105</td><td>196</td><td>0.02</td></tr><tr><td>Decode / Traverse / Dealloc (breakdown)</td><td>0 / 0.08 / 0</td><td>220 / 0.15 / 81</td><td>294 / 0.9 / 287</td><td>70 / 0.08 / 35</td><td>41 / 3.9 / 150</td><td>0 / 0.02 / 0</td></tr><tr><td>Encode (1 million times, seconds)</td><td>3.2</td><td>185</td><td>650</td><td>169</td><td>273</td><td>0.15</td></tr><tr><td>Wire format size (normal / zlib, bytes)</td><td>344 / 220</td><td>228 / 174</td><td>1475 / 322</td><td>1029 / 298</td><td>1137 / 341</td><td>312 / 187</td></tr><tr><td>Memory needed to store decoded wire (bytes / blocks)</td><td>0 / 0</td><td>760 / 20</td><td>65689 / 4</td><td>328 / 1</td><td>34194 / 3</td><td>0 / 0</td></tr><tr><td>Transient memory allocated during decode (KB)</td><td>0</td><td>1</td><td>131</td><td>4</td><td>34</td><td>0</td></tr><tr><td>Generated source code size (KB)</td><td>4</td><td>61</td><td>0</td><td>4</td><td>0</td><td>0</td></tr><tr><td>Field access in handwritten traversal code</td><td>typed accessors</td><td>typed accessors</td><td>manual error checking</td><td>typed accessors</td><td>manual error checking</td><td>typed but no safety</td></tr><tr><td>Library source code (KB)</td><td>15</td><td>some subset of 3800</td><td>87</td><td>43</td><td>327</td><td>0</td></tr></tbody></table><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><ul><li><p>下载flatbuffers源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/google/flatbuffers.git</div></pre></td></tr></table></figure></li><li><p>cmake （源码中已包含cmake,也可自行下载）</p></li><li>编译出flatc</li></ul><p>进入 flatbuffers/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.cmake -G &quot;Unix Makefiles&quot;</div><div class="line">2.make</div></pre></td></tr></table></figure></p><h4 id="java层源码支持"><a href="#java层源码支持" class="headerlink" title="java层源码支持"></a>java层源码支持</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.可以将flatbufffers/java 中的源码copy进项目</div><div class="line"></div><div class="line"> 2.将源码打包成jar(此处选用mvn打包)</div></pre></td></tr></table></figure><ul><li>安装mvn</li></ul><p>1.去官网下载mvn源码<a href="http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.3/binaries/apache-maven-3.5.3-bin.tar.gz" target="_blank" rel="external">mvn下载</a></p><p>2.在.bash_profile中加入如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export M2_HOME=&quot;/Users/wangyang/apache-maven-3.5.3&quot;</div><div class="line"></div><div class="line">export PATH=&quot;$M2_HOME/bin:$PATH&quot;</div></pre></td></tr></table></figure></p><p>3.进入flatbuffers/ </p><blockquote><p> 本质是将flatbuffers/java目录下源码打成jar，但是此目录下没有配置对应的pom.xml</p></blockquote><p>本人尝试自己编写pom文件失败后，最后发现flatbuffers/目录下有此配置文件，坑，在此目录下运行以下命令，会生成target文件夹，在target/文件中找到flatbuffers-java-1.9.0-sources.jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn install</div></pre></td></tr></table></figure><h4 id="scheme文件编写"><a href="#scheme文件编写" class="headerlink" title="scheme文件编写"></a>scheme文件编写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">namespace com.rolan.MyGame;//在java中相当于包名</div><div class="line">include &quot;mydefinitions.fbs&quot;;//可引入其它的schemas</div><div class="line">attribute &quot;priority&quot;;//属性</div><div class="line"></div><div class="line">enum Color : byte &#123; Red = 1, Green, Blue &#125;//枚举</div><div class="line"></div><div class="line">union Any &#123; Monster, Weapon, Pickup &#125;//联合体，类比于enum和 struct</div><div class="line"></div><div class="line">struct Vec3 &#123;//类似于table，但它针对不再添加修改的情形，一些常量，比table内存占用小访问速度更快，</div><div class="line">  x:float;</div><div class="line">  y:float;</div><div class="line">  z:float;</div><div class="line">&#125;</div><div class="line"></div><div class="line">table Monster &#123;//table类似于object，只能在末尾添加新的字段，可以rename</div><div class="line">  pos:Vec3;</div><div class="line">  mana:short = 150;</div><div class="line">  hp:short = 100;</div><div class="line">  name:string;</div><div class="line">  friendly:bool = false (deprecated, priority: 1);//不能删除不再使用的字段，可用deprecated标志</div><div class="line">  inventory:[ubyte];//[types]: ubyte bool short int float double long</div><div class="line">  color:Color = Blue;</div><div class="line">  test:Any;</div><div class="line">&#125;</div><div class="line"></div><div class="line">root_type Monster;//根节点</div></pre></td></tr></table></figure><h4 id="types"><a href="#types" class="headerlink" title="types"></a>types</h4><p> 括号里是别名</p><ul><li>8 bit: byte (int8), ubyte (uint8), bool</li><li>16 bit: short (int16), ushort (uint16)</li><li>32 bit: int (int32), uint (uint32), float (float32)</li><li>64 bit: long (int64), ulong (uint64), double (float64)<h4 id="编译scheme文件"><a href="#编译scheme文件" class="headerlink" title="编译scheme文件"></a>编译scheme文件</h4></li></ul><p>根据schme文件编译生成java entity文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flatc -j[--java] sample_schema.fbs</div></pre></td></tr></table></figure></p><p>根据schme文件编译生成c++ 头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flatc -c[--cpp] sample_schema.fbs</div></pre></td></tr></table></figure><p>根据.proto文件生成.fbs(将protobuffer格式转为flatbuffer)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flatc --proto Person.proto</div></pre></td></tr></table></figure><p>根据.fbs文件和.bin文件生成json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flatc -t schema.fbs -- binary.bin</div></pre></td></tr></table></figure><p>根据schme文件和 json数据文件生成所对应的flatbuffers格式的数据文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flatc -b[--binary] sample_schema.fbs sample_json.json</div></pre></td></tr></table></figure><p>了解其它相关命令<a href="http://google.github.io/flatbuffers/flatbuffers_guide_using_schema_compiler.html" target="_blank" rel="external">官方文档</a></p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>以下面这个scheme为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">namespace com.rolan.entity;</div><div class="line">table PeopleList &#123;</div><div class="line">    peoples : [People];</div><div class="line">&#125;</div><div class="line"></div><div class="line">table People &#123;</div><div class="line">    id : string;</div><div class="line">    index : long;</div><div class="line">    guid : string;</div><div class="line">    name : string;</div><div class="line">    gender : string;</div><div class="line">    company : string;</div><div class="line">    email : string;</div><div class="line">    friends : [Friend];</div><div class="line">&#125;</div><div class="line"></div><div class="line">table Friend &#123;</div><div class="line">    id : long;</div><div class="line">    name : string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">root_type PeopleList;</div></pre></td></tr></table></figure></p><p>java层序列化到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">FlatBufferBuilder builder = new FlatBufferBuilder(0);</div><div class="line">        int peopleList[] = new int[100];</div><div class="line">        for (int i = 0; i &lt; peopleList.length; i++) &#123;</div><div class="line">            int nameOffect1 = builder.createString(&quot;李四&quot;);</div><div class="line">            int nameOffect2 = builder.createString(&quot;张三&quot;);</div><div class="line">            int nameOffect3 = builder.createString(&quot;王五&quot;);</div><div class="line">            int friends[] = new int[3];</div><div class="line">            friends[0] = Friend.createFriend(builder, 3243544, nameOffect1);</div><div class="line">            friends[1] = Friend.createFriend(builder, 2341423, nameOffect2);</div><div class="line">            friends[2] = Friend.createFriend(builder, 1232432, nameOffect3);</div><div class="line">            int index = builder.createString(&quot;23412243&quot;);</div><div class="line">            int guid = builder.createString(&quot;xnvnsfsd&quot;);</div><div class="line">            int name = builder.createString(&quot;赵钱&quot;);</div><div class="line">            int gender = builder.createString(&quot;男&quot;);</div><div class="line">            int company = builder.createString(&quot;阿里妈妈&quot;);</div><div class="line">            int email = builder.createString(&quot;ye@163.com&quot;);</div><div class="line">            int friendsVector = People.createFriendsVector(builder, friends);</div><div class="line">            People.startPeople(builder);</div><div class="line">            People.addId(builder, index);</div><div class="line">            People.addIndex(builder, 3001);//001会被识别成int</div><div class="line">            People.addGuid(builder, guid);</div><div class="line">            People.addName(builder, name);</div><div class="line">            People.addGender(builder, gender);</div><div class="line">            People.addCompany(builder, company);</div><div class="line">            People.addEmail(builder, email);</div><div class="line">            People.addFriends(builder, friendsVector);</div><div class="line">            peopleList[i] = People.endPeople(builder);</div><div class="line">        &#125;</div><div class="line">        int peoplesVector = PeopleList.createPeoplesVector(builder, peopleList);</div><div class="line">        PeopleList.startPeopleList(builder);</div><div class="line">        PeopleList.addPeoples(builder, peoplesVector);</div><div class="line">        int endPeopleList = PeopleList.endPeopleList(builder);</div><div class="line">        builder.finish(endPeopleList);</div><div class="line"></div><div class="line">        ByteBuffer bb = builder.dataBuffer();</div><div class="line">        File file = new File(getCacheDir() + &quot;/test.bin&quot;);</div><div class="line">        try &#123;</div><div class="line">            FileOutputStream fo = new FileOutputStream(file);</div><div class="line">            fo.write(bb.array(), bb.position(), bb.remaining());</div><div class="line">            fo.close();</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>java反序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">File file = new File(getCacheDir() + &quot;/test.bin&quot;);</div><div class="line">       try &#123;</div><div class="line">           byte[] bytes = Utils.toByteArray(file);</div><div class="line">           ByteBuffer wrap = ByteBuffer.wrap(bytes);</div><div class="line">           PeopleList rootAsPeopleList = PeopleList.getRootAsPeopleList(wrap);</div><div class="line">           People peoples = rootAsPeopleList.peoples(1);//取第1个</div><div class="line">           String company = peoples.company();</div><div class="line">           int peopleLength = peoples.friendsLength();</div><div class="line">           Toast.makeText(this,peoples.company(),Toast.LENGTH_SHORT).show();</div><div class="line">       &#125; catch (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div></pre></td></tr></table></figure><p>参考：<a href="http://coolpers.github.io/" target="_blank" rel="external">http://coolpers.github.io/</a><br><a href="https://www.jianshu.com/p/03a2e8918f8a" target="_blank" rel="external">https://www.jianshu.com/p/03a2e8918f8a</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要用flatbuffers-官网&quot;&gt;&lt;a href=&quot;#为什么要用flatbuffers-官网&quot; class=&quot;headerlink&quot; title=&quot;为什么要用flatbuffers 官网&quot;&gt;&lt;/a&gt;为什么要用flatbuffers &lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>从源代码编译React Native</title>
    <link href="http://yoursite.com/2018/03/25/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91React%20Native/"/>
    <id>http://yoursite.com/2018/03/25/从源代码编译React Native/</id>
    <published>2018-03-25T02:36:00.000Z</published>
    <updated>2018-04-27T06:09:27.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从源代码编译React-Native"><a href="#从源代码编译React-Native" class="headerlink" title="从源代码编译React Native"></a>从源代码编译React Native</h4><ul><li>环境准备</li></ul><ol><li>Android SDK version 23 (非必须)</li><li>SDK build tools version 23.0.1 (非必须)</li><li>Android Support Repository &gt;= 17</li><li>Android NDK(必须android-ndk-r10e)</li></ol><hr><ul><li>ndk安装</li></ul><p><a href="http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin" target="_blank" rel="external">android-ndk-r10e下载链接</a><br>1.chmod a+x android-ndk-r10e-darwin-x86_64.bin （申请权限）<br>2.”./android-ndk-r10e-darwin-x86_64.bin” (切勿用工具解压)<br>3.指定ndk路径，打开.bash_profile  输入<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NDK_ROOT=/Users/wangyang/sdk/android-ndk-r10e</div><div class="line">export PATH=$PATH:$NDK_ROOT</div></pre></td></tr></table></figure></p><p>4.source .bash_profile 应用<br>5.检查ndk是否配置成功<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">进入： /Users/wangyang/sdk/android-ndk-r10e/samples/hello-jni </div><div class="line">执行 ndk-build  正常编译则表示配置成功</div><div class="line">在project structure中指定ndk的路径</div><div class="line">/Users/wangyang/sdk/android-ndk-r10e</div></pre></td></tr></table></figure></p><hr><ul><li>项目文件修改</li></ul><p>1.project中 build.gradle添加如下</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">classpath &apos;de.undercouch:gradle-download-task:3.1.2&apos;  //此步骤马上执行sync,不然接下来可能会报错</div></pre></td></tr></table></figure></code></pre><p>2.修改settings.gradle</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">include &apos;:ReactAndroid&apos;</div><div class="line">project(&apos;:ReactAndroid&apos;).projectDir = new File(settingsDir, &apos;.  ./rn/node_modules/react-native/ReactAndroid&apos;)</div></pre></td></tr></table></figure></code></pre><p>3.app build.gradle 修改</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dependencies&#123;</div><div class="line">       api project(&apos;:ReactAndroid&apos;)</div><div class="line">     此处需要注释掉所有测试相关的依赖</div><div class="line">    &#125;</div><div class="line">configurations.all &#123;</div><div class="line">           exclude group: &apos;com.facebook.react&apos;, module: &apos;react-native&apos;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></code></pre><p>4.ReactAndroid 项目修改</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.移动与ReactAndroid 同级的 ReactCommon到ReactAndroid（此步可有可无）</div><div class="line">修改 build.gradle &quot;REACT_COMMON_DIR=$projectDir/../ReactCommon&quot; 为&quot;REACT_COMMON_DIR=$projectDir/ReactCommon&quot;,（有两处需修改）</div></pre></td></tr></table></figure></code></pre><p>5.app第三方本地依赖修改</p><ul><li><p>注销掉原来的react-native 依赖</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opensourcelibrary moudle中</div><div class="line">//api &apos;com.facebook.react:react-native:+&apos;</div></pre></td></tr></table></figure></li><li><p>第三方本地引入依赖修改 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.horcrux.svg 此包整个从组件库中移入主项目中，不然会报找不到react相关的包</div></pre></td></tr></table></figure></li></ul><h4 id="androidStudio-3-0的兼容处理"><a href="#androidStudio-3-0的兼容处理" class="headerlink" title="androidStudio 3.0的兼容处理"></a>androidStudio 3.0的兼容处理</h4><ul><li><p>修改前(ReactAndroid/release.gradle)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def getRepositoryUrl() &#123;</div><div class="line">          return hasProperty(&apos;repositoryUrl&apos;) ? property(&apos;repositoryUrl&apos;) : &apos;https://oss.sonatype .org/service/local/staging/deploy/maven2/&apos;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">def getRepositoryUsername() &#123;</div><div class="line">          return hasProperty(&apos;repositoryUsername&apos;) ? property(&apos;repositoryUsername&apos;) : &apos;&apos;</div><div class="line">      &#125;</div><div class="line">def getRepositoryPassword() &#123;</div><div class="line">          return hasProperty(&apos;repositoryPassword&apos;) ? property(&apos;repositoryPassword&apos;) : &apos;&apos;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></li><li><p>修改后</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def getRepositoryUrl() &#123;</div><div class="line">          return findProperty(&apos;repositoryUrl&apos;) != null ? property(&apos;repositoryUrl&apos;) : &apos;https://oss.sonatype.org/service/local/staging/deploy/maven2/&apos;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">def getRepositoryUsername() &#123;</div><div class="line">          return findProperty(&apos;repositoryUsername&apos;) !=null ? property(&apos;repositoryUsername&apos;) : &apos;&apos;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">def getRepositoryPassword() &#123;</div><div class="line">          return findProperty(&apos;repositoryPassword&apos;) != null ? property(&apos;repositoryPassword&apos;) : &apos;&apos;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></li></ul><h4 id="网络耗时任务的处理"><a href="#网络耗时任务的处理" class="headerlink" title="网络耗时任务的处理"></a>网络耗时任务的处理</h4><p>  下载的文件放入 ReactAndroid/build/downloads下<a href="https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz" target="_blank" rel="external">boost下载</a></p><p> 正常情况下只需要下载boost，其它的在编译时自动下载，如果下载不成功就采取手动下载，链接的资源如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz</div><div class="line">https://github.com/google/double-conversion/archive/v1.1.1.tar.gz</div><div class="line">https://github.com/facebook/folly/archive/v2016.09.26.00.tar.gz</div><div class="line">https://github.com/google/glog/archive/v0.3.3.tar.gz</div><div class="line">https://raw.githubusercontent.com/WebKit/webkit/38b15a3ba3c1b0798f2036f7cea36ffdc096202e/Source/JavaScriptCore/API/</div><div class="line">           头文件只下载此数组中的[&apos;JavaScript.h&apos;, &apos;JSBase.h&apos;, &apos;JSContextRef.h&apos;, &apos;JSObjectRef.h&apos;, &apos;JSRetainPtr.h&apos;, &apos;JSStringRef.h&apos;, &apos;JSValueRef.h&apos;, &apos;WebKitAvailability.h&apos;]</div><div class="line">            下载的头文件放入 downloads/jsc目录下</div></pre></td></tr></table></figure></p><h4 id="其它踩坑指南"><a href="#其它踩坑指南" class="headerlink" title="其它踩坑指南"></a>其它踩坑指南</h4><p>  ReactNative 暂时还不支持新版的 api依赖等方式，所以需要保持 compile<br>  下面这个任务会不通过，因为此任务会去compile中复制一些文件过来</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">task prepareJSC(dependsOn: dependenciesPath ? [] : [downloadJSCHeaders]) &lt;&lt; &#123;</div><div class="line">          copy &#123;</div><div class="line">            from zipTree(configurations.compile.fileCollection &#123; dep -&gt; dep.name == &apos;android-jsc&apos;  &#125;.singleFile)</div><div class="line">            from dependenciesPath ? &quot;$dependenciesPath/jsc-headers&quot; : &#123;downloadJSCHeaders.dest&#125;</div><div class="line">            from &apos;src/main/jni/third-party/jsc/Android.mk&apos;</div><div class="line">               include &apos;jni/**/*.so&apos;, &apos;*.h&apos;, &apos;Android.mk&apos;</div><div class="line">               filesMatching(&apos;*.h&apos;, &#123; fname -&gt; fname.path = &quot;JavaScriptCore/$&#123;fname.path&#125;&quot;&#125;)</div><div class="line">              into &quot;$thirdPartyNdkDir/jsc&quot;;</div><div class="line">         &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></code></pre><ul><li><p>React 不支持 D8的merge dex工具</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">需要关闭此属性，在project/gradle.properties中</div><div class="line">android.enableD8=false  默认就是关闭</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从源代码编译React-Native&quot;&gt;&lt;a href=&quot;#从源代码编译React-Native&quot; class=&quot;headerlink&quot; title=&quot;从源代码编译React Native&quot;&gt;&lt;/a&gt;从源代码编译React Native&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 常见命令及其操作</title>
    <link href="http://yoursite.com/2017/04/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/04/10/Git常用命令/</id>
    <published>2017-04-10T15:16:00.000Z</published>
    <updated>2018-04-27T06:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h5 id="基本Git-命令"><a href="#基本Git-命令" class="headerlink" title="基本Git 命令"></a>基本Git 命令</h5><pre><code>1. 配置Git    git config --global user.name &quot;YourName&quot;    git config --global user.email &quot;email@example.com&quot;2. 创建版本库    git init3. 查看当前版本库的状态    git status4. 查看当前窗口的所有log    git log --pretty=oneline5. 查看历史log    git reflog6. 添加文件到暂存区    git add readme.txt    git add .                                一次添加所有的文件    7. 提交修改    git commit -m &quot;example commit&quot;8. 版本回退    git reset --hard 23230(commit id)       回退到指定版本           git reset --hard HEAD^                  回退到上一个版本    git reset --hard HEAD~8                 回退到前8的那个版本9. 撤销修改    git checkout -- readme.md10. 撤销暂存区(git add)的修改，重新放回工作区    git reset HEAD readme.txt11. 从版本库中删除文件    git rm test.txt12. 对比不同，查看修改的内容    git diff readme.txt13. 删除已经被提交的文件（本地加入ignore，需要删除远程仓库中的）    git rm -r build.xml                        从版本库中删除（单个文件）    git rm -r build/                        从版本库中删除（整个build目录）    git commit -m &quot;ignore commit files&quot;        提交    git push origin master                    推送到远程仓库14.回滚代码    git checkout -b sm v4.9.7      本地建个sm分支跟踪 v4.9.7 tag    git push -f origin sm:master   强制把master回滚到 sm 分支（相当于回滚到 4.9.7tag）    git branch -D master       删除并重建本地master    git checkout -b master --track origin/master</code></pre><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><pre><code>1. 使用Coding创建一个远程仓库2. 运行命令    git remote add origin https://github.com/googlesamples/android-ndk.git3. 将本地库的所有内容推送到远程仓库上    git push -u origin master    （初次提交）    git push origin master        （初次提交后再次提交）4. 从远程仓库克隆    git clone https://github.com/googlesamples/android-ndk.git        （远程 master分支）    git clone -b dev https://github.com/googlesamples/android-ndk.git    （远程 dev分支）</code></pre><h5 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h5><pre><code>1. 创建分支    git branch dev2. 切换分支    git checkout dev3. 创建并切换分支    git checkout -b dev4. 查看当前分支    git branch5. 删除分支    git branch -d dev6. 推送本地的分支到服务器    git push origin dev7. 查看本地与远程的所有分支    git branch -a8. 删除远程分支    git push origin --delete dev9. 删除远程tag    git push origin --delete tag tag_1</code></pre><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><pre><code>1. 使用 git merge dev 合并分支代码时，Git会使用&lt;&lt;&lt;&lt;&lt;&lt;,======,&gt;&gt;&gt;&gt;&gt;&gt;标记处不同分支的内容，待我们手动合并冲突后，保存之后重新提交即可完成分支合并2. 使用命令查看分支合并图   git log --graph</code></pre><h5 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h5><p> <img src="manage_branch.png" alt="分支管理策略"></p><pre><code>1. 通常，合并分支时，如果可能，Git会使用Fast forward模式，但在这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，从分支历史就可以看出分支信息。2. 使用如下命令禁用Fast forward模式    git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></pre><h5 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h5><pre><code>1. 接到修复代号101bug的任务，创建一个分支issue-101来修复它。但是，当前正在dev上进行的工作还没有提交。    存储工作现场，存储之后 git status将没有内容，即工作区是干净的。    git stash    存储工作现场2. 新建分支issue-101修复bug，并合并到master分支。    git checkout -b issue-101     git add motifity.java    git commit motiffity.java    git checkout master    git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101    git branch -d issue-1013. 切回dev分支干活，并恢复现场    git stash list      查看刚才的工作现场    git stash apply     恢复最近的工作现场    git stash drop      删除存储的工作现场4. 一步恢复工作现场，恢复的同时把stash内容也删了    git stash pop     5. stash的其它命令    git stash apply stash@{0}    恢复指定的工作现场    git stash show -p stash@{0}   对比指定工作现场与当前所发生的改变    git stash show -p            对比最近工作现场与当前所发生的改变    git stash save xxxxx         带有指定信息的存储工作现场    git stash drop  stash@{0}    抛弃指定的工作现场    gut stash branch develop_test  以当前存储的工作现场创建并切换到分支 develop_test</code></pre><h5 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h5><pre><code>1. 创建一个分支，用于开发下一代星际飞船    git checkout -b feature-vulcan2. 飞船开发完成，切换到dev分支准备合并    git add vulcan    git commit -m &quot;feature vulcan&quot;    git checkout dev3. 经费不足，新功能取消    git branch -d feature-vulcan    (失败，未经合并的分支)    git branch -D feature-vulcan    强制删除</code></pre><h5 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h5><pre><code>1. 查看远程库信息    git remote    git remote -v       查看更详细的信息(Git库远程地址)2. 推送分支    git push origin master    git push origin dev    master分支是主分支，因此需要时刻与远程同步；    dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；    bug分支只用于在本地修复bug，就没有必要推送到远程了，除非老板要看你每周到底修复了几个bug；    feature分支是否推送到远程，取决于你是否和你的小伙伴合作在上面开发3. 抓取（克隆）分支    git clone https://github.com/googlesamples/android-ndk.git    默认情况下，clone下来时，本地只能看到master分支    需要从dev分支开发，在本地创建dev分支：    git checkout -b dev origin/dev4. 指定本地dev分支与远程origin/dev分支的链接    git branch --set-upstream dev origin/dev5. 从服务器拉取最新内容    git pull</code></pre><h5 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h5><pre><code>1. 创建标签    git tag v1.02. 查看所有标签    git tag3. 从某次提交创建标签    git tag v0.9 822834. 带说明文字    git tag -a v0.1 -m &quot;version 0.1 released&quot; 2323            -a 指定标签名            -m 指定说明文字    git show v0.1   查看说明文字5. 删除标签    git tag -d v1.06. 推送标签到远程    git push origin v1.07. 从远程库删除    git push origin :refs/tags/v1.0</code></pre><h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><pre><code>1. 忽略掉Git工作目录中不需要提交的文件，如.class文件。创建.gitignore文件即可2. 某些时候，无法添加文件到Git    git add -f demo.java        -f 强制添加3. 如果.gitignore写的有问题，使用命令检查     git check-ignore -v demo.java       该命令会告知.gitignore哪里写得有问题</code></pre><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><pre><code>1. 避免每次pull/push都输入账户名与密码。在config文件中加入如下命令    [credential]            helper = store2. Git默认对大小写不明感，加入如下配置命令不忽略大小写    git config core.ignorecase false  </code></pre><p>感谢好朋友小滔滔无私的付出，文章大部分是引用自他：<a href="https://github.com/chentao7v" target="_blank" rel="external">他的Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h5 id=&quot;基本Git-命令&quot;&gt;&lt;a href=&quot;#基本Git-命令&quot; class=&quot;headerlink&quot; title=&quot;基本Git 命令&quot;&gt;&lt;/a&gt;基本Git 命令&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;1. 配置Git
    git config --global 
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>one</title>
    <link href="http://yoursite.com/2016/12/13/one/"/>
    <id>http://yoursite.com/2016/12/13/one/</id>
    <published>2016-12-13T05:53:00.000Z</published>
    <updated>2018-04-11T07:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>   大 扶<br>   鹏 摇<br>   一 直<br>   日 上<br>   同 九<br>   风 万<br>   起 里</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;   大 扶&lt;br&gt;   鹏 摇&lt;br&gt;   一 直&lt;br&gt;   日 上&lt;br&gt;   同 九&lt;br&gt;   风 万&lt;br&gt;   起 里&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/09/25/hello-world/"/>
    <id>http://yoursite.com/2016/09/25/hello-world/</id>
    <published>2016-09-25T02:36:00.000Z</published>
    <updated>2018-04-27T06:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>想开通blog已久，无奈懒癌缠身，正值周一疲劳之际，得空产出这么一个东东，我一直有诗人一样的情怀，常不禁遐想自己漫步于两岸花丛绿地间，观虫草走兽，听山谷青翠空灵，然事与愿违，这一切都活在我的梦里。</p><p>好了，正文开始：</p><p>这是我个人的第一篇blog,相信应该，可能也不会是最后一篇(<em>^__^</em>)，我打算将生活中的有趣的事，以及学习中比较深刻的见解在这里记录下来。</p><p>首先，得给自己立一个小目标：</p><ul><li>C++原生游戏开发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.java与native层互调</div><div class="line">2.c++事件响应模型</div><div class="line">3.3D立体渲染</div></pre></td></tr></table></figure><ul><li>es5,6</li><li><p>React Native混合开发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.node基础</div><div class="line">2.es5,6基础，特性</div><div class="line">3.react基础</div><div class="line">4.reduce及其事件模型</div></pre></td></tr></table></figure></li><li><p>组件化探索</p></li><li>Android源码分析</li><li>Java web</li><li>python把玩</li><li>区块链挖掘</li></ul><hr><p>可以看到，要成为一名合格的程序员，还有很长的路要走，况且身为一名Android开发，更是感觉前路遍布荆棘（ps:如果你认为Android很简单，那么证明你还没入门）</p><p>梦想是要有的，万一实现了呢，但是理想也要与现实着地，所以你能看到我列出的目录中，都是时下非常热门的技术和方向，人最不可避免的就是自己的惰性，高中时期在那种大环境下才能做到勉强自律，更不用提毕业工作后面对生活的压力，及其它因素的诱惑。问题既然摆在那，很少有人能有勇气和恒心去解决问题，因为这不是短期投资，你很难在一天或者是一周后看到回报，温水煮青蛙就是这个理，我们务必时时鞭策自己，告诉自己在前面等待自己的是多么美好的未来，对自己痛苦，就是成全自己。</p><p>如果你解决一个问题，你就领先很多人，解决越多问题，你的生活也就会过得更滋润。所以我一直标榜自己是一个“解决问题的人”，但这同时让我失去了创造性。有得有失这不可避免，但是我们要尽量做到在大趋势下不犯错。</p><ul><li><p>总结</p><p>   一不小心立了很多大方向，本人工作还算比较忙，所以可能进度比较慢，但是，你想的没错，我就是喜欢暴饮暴食，一口吃成一个胖子的何许人hahaa…,不过凡事都要有重点，先后之分，所以近期我会在这个大方向内出一篇文章，至于具体讲什么，还请下回分解。</p></li><li><p>下面是博客相关的资料</p><p>  Hexo官方网站：</p><p>  <a href="https://hexo.io/" target="_blank" rel="external">https://hexo.io/</a></p><p>  Hexo中文文档：</p><p>  <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/index.html</a></p><p>  博客搭建过程</p><p>  <a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a></p><p>  新增文章：</p><p>  在source/目录下建立 xx.md   然后   hexo generate –deploy  即可自动生成及其上传GitHub</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;想开通blog已久，无奈懒癌缠身，正值周一疲劳之际，得空产出这么一个东东，我一直有诗人一样的情怀，常不禁遐想自己漫步于两岸花丛绿地间，观虫草走兽，听山谷青翠空灵，然事与愿违，这一切都活在我的梦里。&lt;/p&gt;
&lt;p&gt;好了，正文开始：&lt;/p&gt;
&lt;p&gt;这是我个人的第一篇b
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
